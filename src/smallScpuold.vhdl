-- generated by Digital. Don't modify this file!
-- Any changes will be lost if this file is regenerated.

library ieee;
  use ieee.std_logic_1164.all;

entity MUX_GATE_BUS_3 is
  generic (Bits : integer);
  port (
    p_out : out std_logic_vector((Bits - 1) downto 0);
    sel   : in  std_logic_vector(2 downto 0);

    in_0  : in  std_logic_vector((Bits - 1) downto 0);
    in_1  : in  std_logic_vector((Bits - 1) downto 0);
    in_2  : in  std_logic_vector((Bits - 1) downto 0);
    in_3  : in  std_logic_vector((Bits - 1) downto 0);
    in_4  : in  std_logic_vector((Bits - 1) downto 0);
    in_5  : in  std_logic_vector((Bits - 1) downto 0);
    in_6  : in  std_logic_vector((Bits - 1) downto 0);
    in_7  : in  std_logic_vector((Bits - 1) downto 0));
end entity;

architecture Behavioral of MUX_GATE_BUS_3 is
begin
  with sel select
    p_out <=                         in_0 when "000",
                                     in_1 when "001",
                                     in_2 when "010",
                                     in_3 when "011",
                                     in_4 when "100",
                                     in_5 when "101",
                                     in_6 when "110",
                                     in_7 when "111",
                     (others => '0') when others;
end architecture;

library ieee;
  use ieee.std_logic_1164.all;

entity DIG_D_FF is
  generic (
    tempVar : std_logic);
  port (D    : in  std_logic;
        C    : in  std_logic;
        Q    : out std_logic;
        notQ : out std_logic);
end entity;

architecture Behavioral of DIG_D_FF is
  signal state : std_logic := tempVar;
begin
  Q    <= state;
  notQ <= not (state);

  process (C)
  begin
    if rising_edge(C) then
      state <= D;
    end if;
  end process;
end architecture;

library ieee;
  use ieee.std_logic_1164.all;

entity DIG_Register_BUS is
  generic (Bits : integer);
  port (
    Q  : out std_logic_vector((Bits - 1) downto 0);
    D  : in  std_logic_vector((Bits - 1) downto 0);
    C  : in  std_logic;
    en : in  std_logic);
end entity;

architecture Behavioral of DIG_Register_BUS is
  signal state : std_logic_vector((Bits - 1) downto 0) := (others => '0');
begin
  Q <= state;

  process (C)
  begin
    if rising_edge(C) and (en = '1') then
      state <= D;
    end if;
  end process;
end architecture;

library ieee;
  use ieee.std_logic_1164.all;

entity MUX_GATE_BUS_1 is
  generic (Bits : integer);
  port (
    p_out : out std_logic_vector((Bits - 1) downto 0);
    sel   : in  std_logic;

    in_0  : in  std_logic_vector((Bits - 1) downto 0);
    in_1  : in  std_logic_vector((Bits - 1) downto 0));
end entity;

architecture Behavioral of MUX_GATE_BUS_1 is
begin
  with sel select
    p_out <=                       in_0 when '0',
                                   in_1 when '1',
                   (others => '0') when others;
end architecture;

library ieee;
  use ieee.std_logic_1164.all;
  use IEEE.NUMERIC_STD.all;

entity DIG_ROM_bootrom is
  port (
    D   : out std_logic_vector(15 downto 0);
    A   : in  std_logic_vector(7 downto 0);
    sel : in  std_logic);
end entity;

architecture Behavioral of DIG_ROM_bootrom is
  type mem is array (0 to 22) of std_logic_vector(15 downto 0);
  constant my_Rom : mem := (
    "0011110100000010", "0000000000000000", "0100010000000000",
    "0011111101010000", "1001000110101101", "0000100111000000",
    "0011111110001100", "0100011100000000", "0011111101010000",
    "0100011100000000", "0011111101010000", "0100011100000000",
    "0011111101010000", "1001000110101101", "0000100111000000",
    "0011111110001100", "0100011100000000", "0011111101010000",
    "0000000000000000", "0000000000000000", "0100011100000000",
    "0011111101010000", "0011110111101100");
begin
  process (A, sel)
  begin
    if sel = '0' then
      D <= (others => 'Z');
    elsif unsigned(A) > "00010110" then
      D <= (others => '0');
    else
      D <= my_rom(to_integer(unsigned(A)));
    end if;
  end process;
end architecture;

library ieee;
  use ieee.std_logic_1164.all;
  --USE ieee.std_logic_unsigned.all;

entity DIG_Add is
  generic (Bits : integer);
  port (
    s   : out std_logic_vector((Bits - 1) downto 0);
    c_o : out std_logic;
    a   : in  std_logic_vector((Bits - 1) downto 0);
    b   : in  std_logic_vector((Bits - 1) downto 0);
    c_i : in  std_logic);
end entity;

architecture Behavioral of DIG_Add is
  function FullAdder(input1, input2, Cin : std_logic) return std_logic is
  begin
    return (input1 xor input2 xor Cin);
  end function;

  function CarryOut(input1, input2, Cin : std_logic) return std_logic is
  begin
    return ((input1 and input2) or (Cin and (input1 xor input2)));
  end function;
  signal Carry : std_logic;
  signal temp  : std_logic_vector(Bits downto 0);
begin
  process (a, b, c_i)
  begin
    Carry <= c_i;
    for i in 0 to Bits - 1 loop
      s(i) <= FullAdder(a(i), b(i), Carry);
      Carry <= CarryOut(a(i), b(i), Carry);
    end loop;
    c_o <= Carry;
  end process;

end architecture;

library ieee;
  use ieee.std_logic_1164.all;

  use IEEE.NUMERIC_STD.all;

entity COMP_GATE_UNSIGNED is
  generic (Bits : integer);
  port (
    gr : out std_logic;
    eq : out std_logic;
    le : out std_logic;
    a  : in  std_logic_vector((Bits - 1) downto 0);
    b  : in  std_logic_vector((Bits - 1) downto 0));
end entity;

architecture Behavioral of COMP_GATE_UNSIGNED is
begin
  process (a, b)
  begin
    if (unsigned(a) > unsigned(b)) then
      le <= '0';
      eq <= '0';
      gr <= '1';
    elsif (unsigned(a) < unsigned(b)) then
      le <= '1';
      eq <= '0';
      gr <= '0';
    else
      le <= '0';
      eq <= '1';
      gr <= '0';
    end if;
  end process;
end architecture;

library ieee;
  use ieee.std_logic_1164.all;
  use ieee.numeric_std.all;

entity singExtend is
  port (
    inst : in  std_logic_vector(15 downto 0); -- instruction word
    n4S  : out std_logic_vector(15 downto 0); -- The four bits taken from Rs.
    n8SD : out std_logic_vector(15 downto 0); -- The eight bits taken from Rs,Rd with sign extension.
    n4D  : out std_logic_vector(15 downto 0)  -- The four bits taken from Rd.
  );
end entity;

architecture Behavioral of singExtend is
  signal s0 : std_logic;
begin
  n4D(3 downto 0)  <= inst(7 downto 4);
  n4D(15 downto 4) <= "000000000000";
  n4S(3 downto 0)  <= inst(3 downto 0);
  n4S(15 downto 4) <= "000000000000";
  s0               <= inst(7);
  n8SD(6 downto 0) <= inst(6 downto 0);
  n8SD(7)          <= s0;
  n8SD(8)          <= s0;
  n8SD(9)          <= s0;
  n8SD(10)         <= s0;
  n8SD(11)         <= s0;
  n8SD(12)         <= s0;
  n8SD(13)         <= s0;
  n8SD(14)         <= s0;
  n8SD(15)         <= s0;
end architecture;

library ieee;
  use ieee.std_logic_1164.all;
  use ieee.numeric_std.all;

entity controllogic is
  port (
    A      : in  std_logic;
    B      : in  std_logic;
    C      : in  std_logic;
    D      : in  std_logic;
    E      : in  std_logic;
    F      : in  std_logic;
    G      : in  std_logic;
    muxb0  : out std_logic;
    muxb1  : out std_logic;
    muxb2  : out std_logic;
    src2D  : out std_logic;
    aluop0 : out std_logic;
    aluop1 : out std_logic;
    aluop2 : out std_logic;
    aluop3 : out std_logic;
    aluop4 : out std_logic;
    WE     : out std_logic;
    sf     : out std_logic;
    alu2D  : out std_logic;
    iem0   : out std_logic;
    iem1   : out std_logic;
    br0    : out std_logic;
    br1    : out std_logic;
    br2    : out std_logic;
    muxA   : out std_logic;
    ld     : out std_logic;
    st     : out std_logic;
    p_abs  : out std_logic;
    ioW    : out std_logic;
    ioR    : out std_logic;
    stPC   : out std_logic;
    Reti   : out std_logic;
    rand   : out std_logic);
end entity;

architecture Behavioral of controllogic is
  signal s0 : std_logic;
  signal s1 : std_logic;
  signal s2 : std_logic;
  signal s3 : std_logic;
  signal s4 : std_logic;
  signal s5 : std_logic;
  signal s6 : std_logic;
begin
  s5     <= not A;
  s0     <= not B;
  s1     <= not C;
  s2     <= not D;
  s3     <= not E;
  s6     <= not F;
  s4     <= not G;
  muxb0  <= ((A and s0 and s1 and s2 and s3 and F and s4) or (A and s0 and s1 and s2 and E and F and G) or (s5 and s1 and D and E and F and s4) or (s5 and B and C and s3 and s6 and s4) or (s5 and s0 and s1 and D and F and s4) or (s5 and s0 and s1 and D and E and s4) or (s5 and s0 and C and s2 and s3 and s4) or (s5 and B and s1 and s2 and s3 and G) or (s5 and C and D and s6 and G) or (s5 and C and s2 and E and G) or (s5 and B and C and E and G) or (s5 and B and C and s2 and E));
  muxb1  <= ((A and s0 and s1 and s2 and E and F and s4) or (s5 and C and s2 and s3 and s6 and G) or (s5 and B and s1 and s2 and s3 and s4) or (A and s0 and s1 and s2 and s3 and G) or (A and s0 and s1 and s2 and s3 and s6) or (s5 and s1 and D and F and G) or (s5 and C and D and s6 and s4) or (s5 and B and C and s6 and G) or (s5 and B and C and F and s4) or (s5 and C and s2 and E and s4) or (s5 and s0 and s1 and D and G) or (s5 and B and D and E) or (s5 and B and C and E));
  muxb2  <= ((s5 and B and C and D and E and F and G) or (s5 and C and s2 and s3 and s6 and s4) or (s5 and B and s2 and s3 and F and G) or (s5 and B and s1 and s3 and F and G) or (s5 and s0 and s1 and D and F and s4) or (s5 and s0 and C and D and s6 and G) or (A and s0 and s1 and s2 and F and G) or (s5 and s0 and C and s2 and s3 and s4) or (s5 and s0 and C and s2 and E and G) or (s5 and B and s1 and s2 and s3 and G) or (A and s0 and s1 and s2 and s3 and s4) or (s5 and s1 and D and E and s4));
  src2D  <= ((s5 and s0 and s1 and s2 and s3 and s6 and G) or (s5 and B and s1 and D and s3 and F and G) or (s5 and B and s1 and D and E and s6 and G) or (s5 and B and C and s2 and s3 and s6 and G) or (A and s0 and s1 and s2 and s3 and s6 and s4) or (s5 and B and D and E and F and s4) or (s5 and B and C and D and E and F));
  aluop0 <= ((s5 and s0 and s1 and D and E and F and s4) or (s5 and s0 and C and s2 and s3 and s6 and G) or (s5 and s0 and C and s2 and s3 and F and s4) or (s5 and s0 and C and D and E and F and G) or (s5 and s1 and s2 and s3 and F and G) or (s5 and s0 and s1 and E and s6 and G) or (s5 and B and s1 and s2 and F));
  aluop1 <= ((s5 and s0 and C and D and s3 and F and G) or (A and s0 and s1 and s2 and E and s6 and G) or (A and s0 and s1 and s2 and E and F and s4) or (s5 and B and s1 and D and s3 and s4) or (s5 and s0 and C and D and E and s6) or (s5 and B and s1 and D and s3 and s6) or (s5 and B and s1 and s2 and E));
  aluop2 <= ((s5 and B and s1 and D and s3 and F and s4) or (A and s0 and s1 and s2 and E and s6 and G) or (A and s0 and s1 and s2 and E and F and s4) or (s5 and s0 and s2 and E and F and G) or (s5 and s0 and D and s3 and s6 and s4) or (s5 and s0 and C and s3 and F and G) or (s5 and s0 and C and s2 and E and F) or (s5 and s0 and C and D and s6) or (s5 and s0 and C and D and s3));
  aluop3 <= ((s5 and s0 and D and E and F and G) or (s5 and s0 and C and D and F and s4) or (s5 and s0 and s2 and E and s6) or (s5 and B and s1 and s3 and s6) or (s5 and s0 and C and s2 and s3) or (s5 and B and s1 and s2 and s3) or (s0 and s1 and s2 and E and s6 and G) or (s0 and s1 and s2 and E and F and s4));
  aluop4 <= ((s5 and B and C and s2 and s3 and s6 and G) or (s5 and B and C and s2 and s3 and F and s4) or (A and s0 and s1 and s2 and s3 and s6 and s4) or (s5 and s1 and D and E and s6 and s4) or (s5 and s0 and s1 and E and F and s4) or (s5 and s0 and s1 and s2 and F and s4) or (s5 and s0 and C and D and s3 and G) or (s5 and B and s1 and s2 and E and G) or (s5 and B and s1 and D and s3 and G) or (s5 and s0 and s3 and F and G) or (s5 and s0 and D and s6 and s4) or (s5 and s0 and D and E and s6) or (s5 and s0 and C and E and s6) or (s0 and s1 and s2 and s3 and F and G));
  WE     <= ((s5 and D and s3 and F and s4) or (s5 and s1 and E and s6 and s4) or (s5 and s1 and E and F and G) or (s5 and C and s2 and s3 and s4) or (s5 and s1 and D and s3 and s6) or (s5 and C and s2 and s3 and F) or (s5 and s0 and D and s6) or (s5 and s1 and s2 and E) or (s5 and s0 and D and s3) or (s5 and s0 and s1 and D) or (s5 and s0 and C and s2) or (s0 and s1 and s2 and G) or (s0 and s1 and s2 and F));
  sf     <= ((s5 and s1 and D and s3 and s6 and s4) or (s5 and s0 and s2 and F and s4) or (s5 and s0 and D and F and G) or (s5 and s0 and s1 and F and G) or (s5 and s0 and C and s6) or (s5 and B and s1 and s2) or (s5 and s0 and E) or (s0 and s1 and s2 and E and s6 and G) or (s0 and s1 and s2 and E and F and s4));
  alu2D  <= ((s5 and C and s2 and s3 and F and G) or (s5 and s1 and D and s3 and s4) or (s5 and s1 and D and s3 and s6) or (s5 and s0 and E and s6) or (s5 and s0 and s2 and F) or (s5 and s0 and s1 and F) or (s5 and s1 and s2 and E) or (s5 and s0 and C and s3) or (s0 and s1 and s2 and E and s6 and G) or (s0 and s1 and s2 and E and F and s4));
  iem0   <= ((s5 and s0 and C and s2 and s3 and s6 and G) or (A and s0 and s1 and s2 and s3 and s6 and G) or (A and s0 and s1 and s2 and E and F and s4) or (s5 and C and D and E and s6 and s4) or (s5 and s0 and C and D and s6 and s4) or (s5 and B and C and D and F and s4) or (s5 and s0 and C and s2 and E and s4) or (s5 and B and s1 and s2 and s3 and s4) or (s5 and s1 and D and E and G) or (s5 and s0 and s1 and D and G));
  iem1   <= ((s5 and B and s1 and D and E and s6 and G) or (s5 and B and C and D and E and F and s4));
  br0    <= ((s5 and B and C and s2 and E and F and G) or (s5 and B and C and D and s6 and G) or (s5 and B and C and D and s3 and s6));
  br1    <= ((s5 and B and C and s2 and E and s6 and G) or (s5 and B and C and s2 and E and F and s4) or (s5 and B and C and D and s3 and s6));
  br2    <= ((s5 and B and C and D and s3 and s6 and G) or (s5 and B and C and s2 and E and s4) or (s5 and B and C and s2 and E and F));
  muxA   <= ((s5 and B and s1 and D and E and s6 and s4) or (s5 and B and C and s2 and s3 and F and s4) or (A and s0 and s1 and s2 and s3 and G) or (A and s0 and s1 and s2 and s3 and F));
  ld     <= ((s5 and B and s1 and D and E and s6 and s4) or (s5 and B and s1 and D and E and F and G) or (s5 and B and C and s2 and s3 and s4));
  st     <= ((s5 and B and s1 and D and s3 and F and G) or (s5 and B and s1 and D and E and s6 and G) or (s5 and B and s1 and D and E and F and s4) or (s5 and B and C and s2 and s3 and s6 and G));
  p_abs  <= ((s5 and B and C and D and E and s6 and s4) or (A and s0 and s1 and s2 and E and s6 and s4) or (s5 and B and C and D and s3 and F));
  ioW    <= ((A and s0 and s1 and s2 and s3 and s6 and s4) or (s5 and B and C and D and E and F));
  ioR    <= ((A and s0 and s1 and s2 and s3 and G) or (A and s0 and s1 and s2 and s3 and F));
  stPC   <= (s5 and B and C and D and s3 and F and s4);
  Reti   <= (A and s0 and s1 and s2 and E and s6 and s4);
  rand   <= (A and s0 and s1 and s2 and E and F and G);
end architecture;

library ieee;
  use ieee.std_logic_1164.all;
  use ieee.numeric_std.all;

entity DEMUX_GATE_4 is
  generic (
    tempVar : integer);
  port (
    out_0  : out std_logic;
    out_1  : out std_logic;
    out_2  : out std_logic;
    out_3  : out std_logic;
    out_4  : out std_logic;
    out_5  : out std_logic;
    out_6  : out std_logic;
    out_7  : out std_logic;
    out_8  : out std_logic;
    out_9  : out std_logic;
    out_10 : out std_logic;
    out_11 : out std_logic;
    out_12 : out std_logic;
    out_13 : out std_logic;
    out_14 : out std_logic;
    out_15 : out std_logic;
    sel    : in  std_logic_vector(3 downto 0);
    p_in   : in  std_logic);
end entity;

architecture Behavioral of DEMUX_GATE_4 is
begin
  out_0  <= p_in when sel = "0000" else std_logic(to_unsigned(tempVar, 1)(0));
  out_1  <= p_in when sel = "0001" else std_logic(to_unsigned(tempVar, 1)(0));
  out_2  <= p_in when sel = "0010" else std_logic(to_unsigned(tempVar, 1)(0));
  out_3  <= p_in when sel = "0011" else std_logic(to_unsigned(tempVar, 1)(0));
  out_4  <= p_in when sel = "0100" else std_logic(to_unsigned(tempVar, 1)(0));
  out_5  <= p_in when sel = "0101" else std_logic(to_unsigned(tempVar, 1)(0));
  out_6  <= p_in when sel = "0110" else std_logic(to_unsigned(tempVar, 1)(0));
  out_7  <= p_in when sel = "0111" else std_logic(to_unsigned(tempVar, 1)(0));
  out_8  <= p_in when sel = "1000" else std_logic(to_unsigned(tempVar, 1)(0));
  out_9  <= p_in when sel = "1001" else std_logic(to_unsigned(tempVar, 1)(0));
  out_10 <= p_in when sel = "1010" else std_logic(to_unsigned(tempVar, 1)(0));
  out_11 <= p_in when sel = "1011" else std_logic(to_unsigned(tempVar, 1)(0));
  out_12 <= p_in when sel = "1100" else std_logic(to_unsigned(tempVar, 1)(0));
  out_13 <= p_in when sel = "1101" else std_logic(to_unsigned(tempVar, 1)(0));
  out_14 <= p_in when sel = "1110" else std_logic(to_unsigned(tempVar, 1)(0));
  out_15 <= p_in when sel = "1111" else std_logic(to_unsigned(tempVar, 1)(0));
end architecture;

library ieee;
  use ieee.std_logic_1164.all;

entity MUX_GATE_BUS_4 is
  generic (Bits : integer);
  port (
    p_out : out std_logic_vector((Bits - 1) downto 0);
    sel   : in  std_logic_vector(3 downto 0);

    in_0  : in  std_logic_vector((Bits - 1) downto 0);
    in_1  : in  std_logic_vector((Bits - 1) downto 0);
    in_2  : in  std_logic_vector((Bits - 1) downto 0);
    in_3  : in  std_logic_vector((Bits - 1) downto 0);
    in_4  : in  std_logic_vector((Bits - 1) downto 0);
    in_5  : in  std_logic_vector((Bits - 1) downto 0);
    in_6  : in  std_logic_vector((Bits - 1) downto 0);
    in_7  : in  std_logic_vector((Bits - 1) downto 0);
    in_8  : in  std_logic_vector((Bits - 1) downto 0);
    in_9  : in  std_logic_vector((Bits - 1) downto 0);
    in_10 : in  std_logic_vector((Bits - 1) downto 0);
    in_11 : in  std_logic_vector((Bits - 1) downto 0);
    in_12 : in  std_logic_vector((Bits - 1) downto 0);
    in_13 : in  std_logic_vector((Bits - 1) downto 0);
    in_14 : in  std_logic_vector((Bits - 1) downto 0);
    in_15 : in  std_logic_vector((Bits - 1) downto 0));
end entity;

architecture Behavioral of MUX_GATE_BUS_4 is
begin
  with sel select
    p_out <=                           in_0  when "0000",
                                       in_1  when "0001",
                                       in_2  when "0010",
                                       in_3  when "0011",
                                       in_4  when "0100",
                                       in_5  when "0101",
                                       in_6  when "0110",
                                       in_7  when "0111",
                                       in_8  when "1000",
                                       in_9  when "1001",
                                       in_10 when "1010",
                                       in_11 when "1011",
                                       in_12 when "1100",
                                       in_13 when "1101",
                                       in_14 when "1110",
                                       in_15 when "1111",
                       (others => '0') when others;
end architecture;

library ieee;
  use ieee.std_logic_1164.all;
  use ieee.numeric_std.all;

entity RegisterBlock is
  port (
    DataIn : in  std_logic_vector(15 downto 0);
    WE     : in  std_logic;
    clk    : in  std_logic;
    src    : in  std_logic_vector(3 downto 0);
    Dest   : in  std_logic_vector(3 downto 0);
    RDest  : out std_logic_vector(15 downto 0);
    Rsrc   : out std_logic_vector(15 downto 0));
end entity;

architecture Behavioral of RegisterBlock is
  signal s0  : std_logic;
  signal s1  : std_logic_vector(15 downto 0);
  signal s2  : std_logic;
  signal s3  : std_logic_vector(15 downto 0);
  signal s4  : std_logic;
  signal s5  : std_logic_vector(15 downto 0);
  signal s6  : std_logic;
  signal s7  : std_logic_vector(15 downto 0);
  signal s8  : std_logic;
  signal s9  : std_logic_vector(15 downto 0);
  signal s10 : std_logic;
  signal s11 : std_logic_vector(15 downto 0);
  signal s12 : std_logic;
  signal s13 : std_logic_vector(15 downto 0);
  signal s14 : std_logic;
  signal s15 : std_logic_vector(15 downto 0);
  signal s16 : std_logic;
  signal s17 : std_logic_vector(15 downto 0);
  signal s18 : std_logic;
  signal s19 : std_logic_vector(15 downto 0);
  signal s20 : std_logic;
  signal s21 : std_logic_vector(15 downto 0);
  signal s22 : std_logic;
  signal s23 : std_logic_vector(15 downto 0);
  signal s24 : std_logic;
  signal s25 : std_logic_vector(15 downto 0);
  signal s26 : std_logic;
  signal s27 : std_logic_vector(15 downto 0);
  signal s28 : std_logic;
  signal s29 : std_logic_vector(15 downto 0);
  signal s30 : std_logic;
  signal s31 : std_logic_vector(15 downto 0);
begin
  gate0: entity work.DEMUX_GATE_4
    generic map (
      tempVar => 0)
    port map (
      sel    => Dest,
      p_in   => WE,
      out_0  => s0,
      out_1  => s2,
      out_2  => s4,
      out_3  => s6,
      out_4  => s8,
      out_5  => s10,
      out_6  => s12,
      out_7  => s14,
      out_8  => s16,
      out_9  => s18,
      out_10 => s20,
      out_11 => s22,
      out_12 => s24,
      out_13 => s26,
      out_14 => s28,
      out_15 => s30);
  gate1: entity work.DIG_Register_BUS -- R0
  generic map (
    Bits => 16) port map (
    D  => DataIn,
    C  => clk,
    en => s0,
    Q  => s1);
  gate2: entity work.DIG_Register_BUS -- R1
  generic map (
    Bits => 16) port map (
    D  => DataIn,
    C  => clk,
    en => s2,
    Q  => s3);
  gate3: entity work.DIG_Register_BUS -- R2
  generic map (
    Bits => 16) port map (
    D  => DataIn,
    C  => clk,
    en => s4,
    Q  => s5);
  gate4: entity work.DIG_Register_BUS -- R3
  generic map (
    Bits => 16) port map (
    D  => DataIn,
    C  => clk,
    en => s6,
    Q  => s7);
  gate5: entity work.DIG_Register_BUS -- R4
  generic map (
    Bits => 16) port map (
    D  => DataIn,
    C  => clk,
    en => s8,
    Q  => s9);
  gate6: entity work.DIG_Register_BUS -- R5
  generic map (
    Bits => 16) port map (
    D  => DataIn,
    C  => clk,
    en => s10,
    Q  => s11);
  gate7: entity work.DIG_Register_BUS -- R6
  generic map (
    Bits => 16) port map (
    D  => DataIn,
    C  => clk,
    en => s12,
    Q  => s13);
  gate8: entity work.DIG_Register_BUS -- R7
  generic map (
    Bits => 16) port map (
    D  => DataIn,
    C  => clk,
    en => s14,
    Q  => s15);
  gate9: entity work.DIG_Register_BUS -- R8
  generic map (
    Bits => 16) port map (
    D  => DataIn,
    C  => clk,
    en => s16,
    Q  => s17);
  gate10: entity work.DIG_Register_BUS -- R9
  generic map (
    Bits => 16) port map (
    D  => DataIn,
    C  => clk,
    en => s18,
    Q  => s19);
  gate11: entity work.DIG_Register_BUS -- R10
  generic map (
    Bits => 16) port map (
    D  => DataIn,
    C  => clk,
    en => s20,
    Q  => s21);
  gate12: entity work.DIG_Register_BUS -- R11
  generic map (
    Bits => 16) port map (
    D  => DataIn,
    C  => clk,
    en => s22,
    Q  => s23);
  gate13: entity work.DIG_Register_BUS -- R12
  generic map (
    Bits => 16) port map (
    D  => DataIn,
    C  => clk,
    en => s24,
    Q  => s25);
  gate14: entity work.DIG_Register_BUS -- BP
  generic map (
    Bits => 16) port map (
    D  => DataIn,
    C  => clk,
    en => s26,
    Q  => s27);
  gate15: entity work.DIG_Register_BUS -- SP
  generic map (
    Bits => 16) port map (
    D  => DataIn,
    C  => clk,
    en => s28,
    Q  => s29);
  gate16: entity work.DIG_Register_BUS -- RA
  generic map (
    Bits => 16) port map (
    D  => DataIn,
    C  => clk,
    en => s30,
    Q  => s31);
  gate17: entity work.MUX_GATE_BUS_4
    generic map (
      Bits => 16)
    port map (
      sel   => Dest,
      in_0  => s1,
      in_1  => s3,
      in_2  => s5,
      in_3  => s7,
      in_4  => s9,
      in_5  => s11,
      in_6  => s13,
      in_7  => s15,
      in_8  => s17,
      in_9  => s19,
      in_10 => s21,
      in_11 => s23,
      in_12 => s25,
      in_13 => s27,
      in_14 => s29,
      in_15 => s31,
      p_out => RDest);
  gate18: entity work.MUX_GATE_BUS_4
    generic map (
      Bits => 16)
    port map (
      sel   => src,
      in_0  => s1,
      in_1  => s3,
      in_2  => s5,
      in_3  => s7,
      in_4  => s9,
      in_5  => s11,
      in_6  => s13,
      in_7  => s15,
      in_8  => s17,
      in_9  => s19,
      in_10 => s21,
      in_11 => s23,
      in_12 => s25,
      in_13 => s27,
      in_14 => s29,
      in_15 => s31,
      p_out => Rsrc);
end architecture;

library ieee;
  use ieee.std_logic_1164.all;

entity MUX_GATE_2 is
  port (
    p_out : out std_logic;
    sel   : in  std_logic_vector(1 downto 0);

    in_0  : in  std_logic;
    in_1  : in  std_logic;
    in_2  : in  std_logic;
    in_3  : in  std_logic);
end entity;

architecture Behavioral of MUX_GATE_2 is
begin
  with sel select
    p_out <= in_0 when "00",
             in_1 when "01",
             in_2 when "10",
             in_3 when "11",
             '0'  when others;
end architecture;

library ieee;
  use ieee.std_logic_1164.all;
  use ieee.numeric_std.all;

  -- Register for storing large constants.
  -- There is a 1-bit command describing this register. 
  -- In this way, 15 bits can be stored (the 16th bit 
  -- activates the writing of this register and therefore 
  -- is always one). The 16th bit will be set according 
  -- to the 'immediate extend mode' (iem).

entity ImReg is
  port (
    en   : in  std_logic;                     -- enables storage
    iem  : in  std_logic_vector(1 downto 0);  -- immediate extend mode (0: sign extend; 1: extend with 0, 2:extend with S0, 3:extend with D0)
    C    : in  std_logic;
    inst : in  std_logic_vector(15 downto 0); -- the current instruction
    imm  : out std_logic_vector(15 downto 0)  -- The constant of register contents and bit 8.
  );
end entity;

architecture Behavioral of ImReg is
  signal s0 : std_logic_vector(14 downto 0);
  signal s1 : std_logic_vector(14 downto 0);
  signal s2 : std_logic;
  signal s3 : std_logic;
  signal s4 : std_logic;
  signal s5 : std_logic;
begin
                s2 <= inst(0);
                s3 <= inst(4);
                s0 <= inst(14 downto 0);
  gate0: entity work.DIG_Register_BUS -- imm
  generic map (
    Bits => 15) port map (
    D  => s0,
    C  => C,
    en => en,
    Q  => s1);
                s5 <= s1(14);
  gate1: entity work.MUX_GATE_2
      port map (
      sel   => iem,
      in_0  => s5,
      in_1  => '0',
      in_2  => s2,
      in_3  => s3,
      p_out => s4);
  imm(14 downto 0) <= s1;
  imm(15)          <= s4;
end architecture;

library ieee;
  use ieee.std_logic_1164.all;
  use ieee.numeric_std.all;

  -- Arithmetic shift right. An unsigned division by two. 
  -- The lower bit is output as the carry bit, while the 
  -- uppermost bit remains unchanged in order to 
  -- obtain the sign.

entity ASR is
  port (
    Di : in  std_logic_vector(15 downto 0); -- data input
    C  : out std_logic;                     -- carry output
    Do : out std_logic_vector(15 downto 0)  -- data output
  );
end entity;

architecture Behavioral of ASR is
  signal s0 : std_logic;
begin
  C               <= Di(0);
  s0              <= Di(15);
  Do(13 downto 0) <= Di(14 downto 1);
  Do(14)          <= s0;
  Do(15)          <= s0;
end architecture;

library ieee;
  use ieee.std_logic_1164.all;
  use ieee.numeric_std.all;

  -- Swaps the high-byte and the low-byte.

entity SWAP is
  port (
    Di : in  std_logic_vector(15 downto 0); -- data input
    Do : out std_logic_vector(15 downto 0)  -- data output
  );
end entity;

architecture Behavioral of SWAP is
begin
  Do(7 downto 0)  <= Di(15 downto 8);
  Do(15 downto 8) <= Di(7 downto 0);
end architecture;

library ieee;
  use ieee.std_logic_1164.all;
  use ieee.numeric_std.all;

  -- Swaps the 4-bit nibble in the high- and the low-byte.

entity SWAPN is
  port (
    Di : in  std_logic_vector(15 downto 0); -- Data input
    Do : out std_logic_vector(15 downto 0)  -- Data output
  );
end entity;

architecture Behavioral of SWAPN is
begin
  Do(3 downto 0)   <= Di(7 downto 4);
  Do(7 downto 4)   <= Di(3 downto 0);
  Do(11 downto 8)  <= Di(15 downto 12);
  Do(15 downto 12) <= Di(11 downto 8);
end architecture;

library ieee;
  use ieee.std_logic_1164.all;
  use ieee.numeric_std.all;

entity DIG_Neg is
  generic (Bits : integer);
  port (
    p_in  : in  std_logic_vector((Bits - 1) downto 0);
    p_out : out std_logic_vector((Bits - 1) downto 0));
end entity;

architecture Behavioral of DIG_Neg is
begin
  p_out <= std_logic_vector(- signed(p_in));
end architecture;

library ieee;
  use ieee.std_logic_1164.all;
  use ieee.numeric_std.all;

entity DIG_Mul_unsigned is
  generic (Bits : integer);
  port (
    a   : in  std_logic_vector((Bits - 1) downto 0);
    b   : in  std_logic_vector((Bits - 1) downto 0);
    mul : out std_logic_vector((Bits * 2 - 1) downto 0));
end entity;

architecture Behavioral of DIG_Mul_unsigned is
begin

  mul <= std_logic_vector(unsigned(a) * unsigned(b));

end architecture;

library ieee;
  use ieee.std_logic_1164.all;
  use ieee.numeric_std.all;

entity DIG_RAMDualPort is
  generic (
    Bits     : integer;
    AddrBits : integer);
  port (
    D   : out std_logic_vector((Bits - 1) downto 0);
    A   : in  std_logic_vector((AddrBits - 1) downto 0);
    Din : in  std_logic_vector((Bits - 1) downto 0);
    str : in  std_logic;
    C   : in  std_logic;
    ld  : in  std_logic);
end entity;

architecture Behavioral of DIG_RAMDualPort is
  -- CAUTION: uses distributed RAM
  type memoryType is array (0 to (2 ** AddrBits) - 1) of STD_LOGIC_VECTOR((Bits - 1) downto 0);
  signal memory : memoryType;
begin
  process (C)
  begin
    if rising_edge(C) and (str = '1') then
      memory(to_integer(unsigned(A))) <= Din;
    end if;
  end process;
  D <= memory(to_integer(unsigned(A))) when ld = '1' else (others => 'Z');
end architecture;

library ieee;
  use ieee.std_logic_1164.all;

entity DIG_Register is

  port (
    Q  : out std_logic;
    D  : in  std_logic;
    C  : in  std_logic;
    en : in  std_logic);
end entity;

architecture Behavioral of DIG_Register is
  signal state : std_logic := '0';
begin
  Q <= state;

  process (C)
  begin
    if rising_edge(C) and (en = '1') then
      state <= D;
    end if;
  end process;
end architecture;

library ieee;
  use ieee.std_logic_1164.all;
  --USE ieee.std_logic_unsigned.all;

entity DIG_Sub is
  generic (Bits : integer);
  port (
    s   : out std_logic_vector((Bits - 1) downto 0);
    c_o : out std_logic;
    a   : in  std_logic_vector((Bits - 1) downto 0);
    b   : in  std_logic_vector((Bits - 1) downto 0);
    c_i : in  std_logic);
end entity;

architecture Behavioral of DIG_Sub is
  function FullSubtractor(input1, input2, Bin : std_logic) return std_logic is
  begin
    return (input1 xor input2 xor Bin);
  end function;

  function BorrowOut(input1, input2, Bin : std_logic) return std_logic is
  begin
    return ((not input1 and input2) or ((not input1) and Bin) or (Bin and input2));
  end function;

  signal Temp_Borrow : std_logic;
begin
  process (a, b, c_i)
  begin
    Temp_Borrow <= c_i;
    for i in 0 to Bits - 1 loop
      s(i) <= FullSubtractor(a(i), b(i), Temp_Borrow);
      Temp_Borrow <= BorrowOut(a(i), b(i), Temp_Borrow);
    end loop;

    c_o <= Temp_Borrow;
  end process;

end architecture;

library ieee;
  use ieee.std_logic_1164.all;

entity MUX_GATE_4 is
  port (
    p_out : out std_logic;
    sel   : in  std_logic_vector(3 downto 0);

    in_0  : in  std_logic;
    in_1  : in  std_logic;
    in_2  : in  std_logic;
    in_3  : in  std_logic;
    in_4  : in  std_logic;
    in_5  : in  std_logic;
    in_6  : in  std_logic;
    in_7  : in  std_logic;
    in_8  : in  std_logic;
    in_9  : in  std_logic;
    in_10 : in  std_logic;
    in_11 : in  std_logic;
    in_12 : in  std_logic;
    in_13 : in  std_logic;
    in_14 : in  std_logic;
    in_15 : in  std_logic);
end entity;

architecture Behavioral of MUX_GATE_4 is
begin
  with sel select
    p_out <= in_0  when "0000",
             in_1  when "0001",
             in_2  when "0010",
             in_3  when "0011",
             in_4  when "0100",
             in_5  when "0101",
             in_6  when "0110",
             in_7  when "0111",
             in_8  when "1000",
             in_9  when "1001",
             in_10 when "1010",
             in_11 when "1011",
             in_12 when "1100",
             in_13 when "1101",
             in_14 when "1110",
             in_15 when "1111",
             '0'   when others;
end architecture;

library ieee;
  use ieee.std_logic_1164.all;
  use ieee.numeric_std.all;

  -- Moves the data word to the left to higher bits, so it multiplies 
  -- by two. The current carry bit is pushed in at the bottom, and 
  -- the most significant bit is output as a carry bit.

entity LSL is
  port (
    Di : in  std_logic_vector(15 downto 0); -- data input
    Ci : in  std_logic;                     -- carry input
    Do : out std_logic_vector(15 downto 0); -- data output
    Co : out std_logic                      -- carry output
  );
end entity;

architecture Behavioral of LSL is
begin
  Do(0)           <= Ci;
  Do(15 downto 1) <= Di(14 downto 0);
  Co              <= Di(15);
end architecture;

library ieee;
  use ieee.std_logic_1164.all;
  use ieee.numeric_std.all;

  -- Shift right. So a division by two.
  -- The carry bit is inserted at the top. And the least 
  -- significant bit is output as a new carry bit.

entity LSR is
  port (
    Di : in  std_logic_vector(15 downto 0); -- data input
    Ci : in  std_logic;                     -- carry input
    Do : out std_logic_vector(15 downto 0); -- data output
    Co : out std_logic                      -- carry output
  );
end entity;

architecture Behavioral of LSR is
begin
  Do(14 downto 0) <= Di(15 downto 1);
  Do(15)          <= Ci;
  Co              <= Di(0);
end architecture;

library ieee;
  use ieee.std_logic_1164.all;
  use ieee.numeric_std.all;

entity COMP_GATE_SIGNED is
  generic (Bits : integer);
  port (
    gr : out std_logic;
    eq : out std_logic;
    le : out std_logic;
    a  : in  std_logic_vector((Bits - 1) downto 0);
    b  : in  std_logic_vector((Bits - 1) downto 0));
end entity;

architecture Behavioral of COMP_GATE_SIGNED is
begin
  process (a, b)
  begin
    if (signed(a) > signed(b)) then
      le <= '0';
      eq <= '0';
      gr <= '1';
    elsif (signed(a) < signed(b)) then
      le <= '1';
      eq <= '0';
      gr <= '0';
    else
      le <= '0';
      eq <= '1';
      gr <= '0';
    end if;
  end process;
end architecture;

library ieee;
  use ieee.std_logic_1164.all;

entity DIG_D_FF_AS is

  port (
    Q    : out std_logic;
    notQ : out std_logic;
    Set  : in  std_logic;
    D    : in  std_logic;
    C    : in  std_logic;
    Clr  : in  std_logic);
end entity;

architecture Behavioral of DIG_D_FF_AS is
  signal state : std_logic := '0';
begin
  process (Set, Clr, C)
  begin
    if (Set = '1') then
      state <= not ('0');
    elsif (Clr = '1') then
      state <= '0';
    elsif rising_edge(C) then
      state <= D;
    end if;
  end process;

  Q    <= state;
  notQ <= not (state);
end architecture;

library ieee;
  use ieee.std_logic_1164.all;

entity DIG_JK_FF is
  generic (tempVar : std_logic);
  port (
    Q    : out std_logic;
    notQ : out std_logic;
    J    : in  std_logic;
    C    : in  std_logic;
    K    : in  std_logic);
end entity;

architecture Behavioral of DIG_JK_FF is
  signal temp : std_logic := tempVar;
begin
  process (C)
  begin
    if rising_edge(C) then
      if (J = '0' and K = '1') then
        temp <= '0';
      elsif (J = '1' and K = '0') then
        temp <= '1';
      elsif (J = '1' and K = '1') then
        temp <= not (temp);
      end if;
    end if;
  end process;
  Q    <= temp;
  notQ <= not (temp);
end architecture;

library ieee;
  use ieee.std_logic_1164.all;
  use ieee.numeric_std.all;

entity tt_um_main is
  port (
    clk     : in  std_logic;
    ui_in   : in  std_logic_vector(7 downto 0);
    rst_n   : in  std_logic;
    ena     : in  std_logic;
    uio_in  : in  std_logic_vector(7 downto 0);
    uo_out  : out std_logic_vector(7 downto 0);
    uio_out : out std_logic_vector(7 downto 0);
    uio_oe  : out std_logic_vector(7 downto 0));
end entity;

architecture Behavioral of tt_um_main is
  signal muxA         : std_logic;
  signal s0           : std_logic_vector(15 downto 0);
  signal s1           : std_logic_vector(15 downto 0);
  signal s2           : std_logic_vector(15 downto 0);
  signal muxB         : std_logic_vector(2 downto 0);
  signal s3           : std_logic_vector(15 downto 0);
  signal s4           : std_logic_vector(15 downto 0);
  signal s5           : std_logic_vector(15 downto 0);
  signal s6           : std_logic_vector(15 downto 0);
  signal s7           : std_logic_vector(15 downto 0);
  signal OpcodeDebug  : std_logic_vector(15 downto 0);
  signal s8           : std_logic_vector(3 downto 0);
  signal s9           : std_logic_vector(3 downto 0);
  signal OPcode       : std_logic_vector(7 downto 0);
  signal s10          : std_logic_vector(7 downto 0);
  signal st           : std_logic;
  signal ld           : std_logic;
  signal s11          : std_logic_vector(15 downto 0);
  signal WDmux        : std_logic_vector(2 downto 0);
  signal s12          : std_logic_vector(15 downto 0);
  signal Din          : std_logic_vector(15 downto 0);
  signal s13          : std_logic_vector(15 downto 0);
  signal RandomNUM    : std_logic_vector(15 downto 0);
  signal s14          : std_logic_vector(15 downto 0);
  signal s15          : std_logic_vector(1 downto 0);
  signal s16          : std_logic;
  signal s17          : std_logic;
  signal s18          : std_logic;
  signal s19          : std_logic;
  signal s20          : std_logic;
  signal br           : std_logic_vector(2 downto 0);
  signal s21          : std_logic;
  signal sf           : std_logic;
  signal s22          : std_logic;
  signal s23          : std_logic;
  signal intr         : std_logic;
  signal interEn      : std_logic;
  signal FlagOut      : std_logic_vector(15 downto 0);
  signal InterLock    : std_logic;
  signal imm          : std_logic;
  signal s24          : std_logic;
  signal s25          : std_logic;
  signal s26          : std_logic;
  signal Reti         : std_logic;
  signal s27          : std_logic;
  signal s28          : std_logic;
  signal inter        : std_logic;
  signal s29          : std_logic_vector(7 downto 0);
  signal WE           : std_logic;
  signal iem          : std_logic_vector(1 downto 0);
  signal s30          : std_logic_vector(7 downto 0);
  signal s31          : std_logic;
  signal s32          : std_logic_vector(7 downto 0);
  signal s33          : std_logic_vector(7 downto 0);
  signal s34          : std_logic_vector(7 downto 0);
  signal s35          : std_logic_vector(7 downto 0);
  signal p_abs        : std_logic;
  signal s36          : std_logic_vector(7 downto 0);
  signal s37          : std_logic_vector(7 downto 0);
  signal s38          : std_logic;
  signal s39          : std_logic_vector(7 downto 0);
  signal s40          : std_logic;
  signal ioW          : std_logic;
  signal s41          : std_logic;
  signal s42          : std_logic_vector(7 downto 0);
  signal s43          : std_logic;
  signal s44          : std_logic;
  signal s45          : std_logic;
  signal s46          : std_logic;
  signal s47          : std_logic;
  signal s48          : std_logic;
  signal s49          : std_logic;
  signal s50          : std_logic;
  signal s51          : std_logic_vector(7 downto 0);
  signal s52          : std_logic_vector(7 downto 0);
  signal s53          : std_logic;
  signal s54          : std_logic_vector(7 downto 0);
  signal s55          : std_logic;
  signal s56          : std_logic;
  signal sel          : std_logic_vector(3 downto 0);
  signal s57          : std_logic_vector(15 downto 0);
  signal s58          : std_logic_vector(15 downto 0);
  signal s59          : std_logic_vector(15 downto 0);
  signal s60          : std_logic_vector(15 downto 0);
  signal s61          : std_logic_vector(15 downto 0);
  signal s62          : std_logic_vector(15 downto 0);
  signal s63          : std_logic_vector(15 downto 0);
  signal s64          : std_logic_vector(15 downto 0);
  signal s65          : std_logic_vector(15 downto 0);
  signal s66          : std_logic_vector(15 downto 0);
  signal s67          : std_logic_vector(15 downto 0);
  signal s68          : std_logic_vector(15 downto 0);
  signal s69          : std_logic_vector(15 downto 0);
  signal s70          : std_logic;
  signal s71          : std_logic;
  signal s72          : std_logic;
  signal s73          : std_logic;
  signal s74          : std_logic;
  signal s75          : std_logic;
  signal aluOp        : std_logic_vector(4 downto 0);
  signal s76          : std_logic_vector(31 downto 0);
  signal s77          : std_logic;
  signal s78          : std_logic;
  signal s79          : std_logic;
  signal s80          : std_logic;
  signal s81          : std_logic;
  signal s82          : std_logic_vector(15 downto 0);
  signal s83          : std_logic_vector(15 downto 0);
  signal s84          : std_logic;
  signal s85          : std_logic;
  signal s86          : std_logic;
  signal s87          : std_logic;
  signal s88          : std_logic;
  signal s89          : std_logic;
  signal s90          : std_logic;
  signal s91          : std_logic;
  signal s92          : std_logic;
  signal s93          : std_logic;
  signal s94          : std_logic;
  signal s95          : std_logic;
  signal s96          : std_logic;
  signal s97          : std_logic;
  signal s98          : std_logic;
  signal s99          : std_logic;
  signal s100         : std_logic;
  signal s101         : std_logic;
  signal s102         : std_logic;
  signal s103         : std_logic;
  signal s104         : std_logic;
  signal s105         : std_logic;
  signal s106         : std_logic;
  signal s107         : std_logic;
  signal s108         : std_logic;
  signal s109         : std_logic;
  signal s110         : std_logic;
  signal s111         : std_logic;
  signal s112         : std_logic;
  signal s113         : std_logic;
  signal s114         : std_logic;
  signal s115         : std_logic;
  signal s116         : std_logic;
  signal s117         : std_logic;
  signal s118         : std_logic;
  signal s119         : std_logic;
  signal stPC         : std_logic;
  signal RandomNUMSel : std_logic;
  signal ioR          : std_logic;
  signal s120         : std_logic_vector(6 downto 0);
  signal s121         : std_logic_vector(6 downto 0);
  signal s122         : std_logic;
  signal s123         : std_logic;
  signal s124         : std_logic;
  signal s125         : std_logic;
  signal s126         : std_logic;
  signal s127         : std_logic;
  signal s128         : std_logic;
  signal s129         : std_logic;
  signal s130         : std_logic;
  signal s131         : std_logic;
  signal src2D        : std_logic;
  signal s132         : std_logic;
  signal s133         : std_logic;
  signal s134         : std_logic;
  signal s135         : std_logic;
  signal s136         : std_logic;
  signal alu2D        : std_logic;
  signal s137         : std_logic;
  signal s138         : std_logic;
  signal s139         : std_logic;
  signal s140         : std_logic;
  signal s141         : std_logic;
  signal uio_oe_temp  : std_logic_vector(7 downto 0);
begin
                uio_oe_temp <= "00000000";
                s26         <= not clk;
                s28         <= not clk;
                s31         <= not clk;
                s38         <= not clk;
                s53         <= not clk;
                s43         <= ui_in(0);
                s44         <= ui_in(1);
                s45         <= ui_in(2);
                s46         <= ui_in(3);
                s47         <= ui_in(4);
                s48         <= ui_in(5);
                s49         <= ui_in(6);
                s50         <= ui_in(7);
                Din(0)      <= s43;
                Din(1)      <= s44;
                Din(2)      <= s45;
                Din(3)      <= s46;
                Din(4)      <= s47;
                Din(5)      <= s48;
                Din(6)      <= s49;
                Din(7)      <= s50;
                Din(8)      <= '0';
                Din(9)      <= '0';
                Din(10)     <= '0';
                Din(11)     <= '0';
                Din(12)     <= '0';
                Din(13)     <= '0';
                Din(14)     <= '0';
                Din(15)     <= '0';
                s51(0)      <= s43;
                s51(1)      <= s44;
                s51(2)      <= s45;
                s51(3)      <= s46;
                s51(4)      <= s47;
                s51(5)      <= s48;
                s51(6)      <= s49;
                s51(7)      <= s50;
  gate0: entity work.MUX_GATE_BUS_3
    generic map (
      Bits => 16)
    port map (
      sel   => WDmux,
      in_0  => s12,
      in_1  => s11,
      in_2  => Din,
      in_3  => s13,
      in_4  => "0000000000000000",
      in_5  => RandomNUM,
      in_6  => "0000000000000000",
      in_7  => "0000000000000000",
      p_out => s14);
  gate1: entity work.DIG_D_FF -- *
  generic map (
    tempVar => '0') port map (
    D => s25,
    C => s26,
    Q => InterLock);
  gate2: entity work.DIG_D_FF -- *
  generic map (
    tempVar => '0') port map (
    D => s27,
    C => s28,
    Q => s24);
  gate3: entity work.DIG_Register_BUS -- PC
  generic map (
    Bits => 8) port map (
    D  => s30,
    C  => s31,
    en => '1',
    Q  => s29);
  gate4: entity work.DIG_Register_BUS
    generic map (
      Bits => 8)
    port map (
      D  => s36,
      C  => s38,
      en => intr,
      Q  => s39);
  gate5: entity work.DIG_Register_BUS
    generic map (
      Bits => 8)
    port map (
      D  => s52,
      C  => s53,
      en => inter,
      Q  => s54);
  gate6: entity work.MUX_GATE_BUS_1
    generic map (
      Bits => 8)
    port map (
      sel   => InterLock,
      in_0  => s51,
      in_1  => s54,
      p_out => s52);
  gate7: entity work.DIG_ROM_bootrom -- bootrom
  port map (
    A   => s29,
    sel => '1',
    D   => OpcodeDebug);
  gate8: entity work.DIG_Add -- Add One
  generic map (
    Bits => 8) port map (
    a   => s29,
    b   => "00000001",
    c_i => '0',
    s   => s32);
  gate9: entity work.COMP_GATE_UNSIGNED
    generic map (
      Bits => 8)
    port map (
      a  => s52,
      b  => s54,
      gr => s55,
      le => s56);
  gate10: entity work.singExtend
    port map (
      inst => OpcodeDebug,
      n4S  => s4,
      n8SD => s5,
      n4D  => s6);
                 inter            <= (s55 or s56);
                 s13(7 downto 0)  <= s32;
                 s13(15 downto 8) <= "00000000";
                 s8               <= OpcodeDebug(3 downto 0);
                 s9               <= OpcodeDebug(7 downto 4);
                 OPcode           <= OpcodeDebug(15 downto 8);
                 s120             <= OPcode(6 downto 0);
                 imm              <= OPcode(7);
  gate11: entity work.MUX_GATE_BUS_1
    generic map (
      Bits => 7)
    port map (
      sel   => imm,
      in_0  => s120,
      in_1  => "0000000",
      p_out => s121);
                 s128 <= s121(0);
                 s127 <= s121(1);
                 s126 <= s121(2);
                 s125 <= s121(3);
                 s124 <= s121(4);
                 s123 <= s121(5);
                 s122 <= s121(6);
  gate12: entity work.controllogic
      port map (
      A      => s122,
      B      => s123,
      C      => s124,
      D      => s125,
      E      => s126,
      F      => s127,
      G      => s128,
      muxb0  => s129,
      muxb1  => s130,
      muxb2  => s131,
      src2D  => src2D,
      aluop0 => s132,
      aluop1 => s133,
      aluop2 => s134,
      aluop3 => s135,
      aluop4 => s136,
      WE     => WE,
      sf     => sf,
      alu2D  => alu2D,
      iem0   => s137,
      iem1   => s138,
      br0    => s139,
      br1    => s140,
      br2    => s141,
      muxA   => muxA,
      ld     => ld,
      st     => st,
      p_abs  => p_abs,
      ioW    => ioW,
      ioR    => ioR,
      stPC   => stPC,
      Reti   => Reti,
      rand   => RandomNUMSel);
                 s27 <= ((s24 and not Reti) or inter);
  gate13: entity work.RegisterBlock
      port map (
      DataIn => s14,
      WE     => WE,
      clk    => clk,
      src    => s8,
      Dest   => s9,
      RDest  => s0,
      Rsrc   => s1);
                 WDmux(0) <= (stPC or ld or RandomNUMSel);
                 WDmux(1) <= (ioR or stPC);
                 WDmux(2) <= (RandomNUMSel or RandomNUMSel);
                 muxB(0)  <= s131;
                 muxB(1)  <= s130;
                 muxB(2)  <= s129;
                 aluOp(0) <= s136;
                 aluOp(1) <= s135;
                 aluOp(2) <= s134;
                 aluOp(3) <= s133;
                 aluOp(4) <= s132;
                 br(0)    <= s141;
                 br(1)    <= s140;
                 br(2)    <= s139;
                 iem(0)   <= s138;
                 iem(1)   <= s137;
  gate14: entity work.MUX_GATE_BUS_1
    generic map (
      Bits => 16)
    port map (
      sel   => muxA,
      in_0  => s0,
      in_1  => s1,
      p_out => s2);
  gate15: entity work.ImReg
    port map (
      en   => imm,
      iem  => iem,
      C    => clk,
      inst => OpcodeDebug,
      imm  => s3);
                 s15 <= br(1 downto 0);
                 s42 <= s1(7 downto 0);
                 sel <= aluOp(3 downto 0);
  gate16: entity work.MUX_GATE_BUS_3
    generic map (
      Bits => 16)
    port map (
      sel   => muxB,
      in_0  => s1,
      in_1  => "0000000000000000",
      in_2  => s3,
      in_3  => "0000000000000000",
      in_4  => "0000000000000000",
      in_5  => s4,
      in_6  => s5,
      in_7  => s6,
      p_out => s7);
  gate17: entity work.ASR
    port map (
      Di => s2,
      C  => s75,
      Do => s66);
  gate18: entity work.SWAP
    port map (
      Di => s2,
      Do => s67);
  gate19: entity work.SWAPN
    port map (
      Di => s2,
      Do => s68);
                 s62 <= not s2;
  gate20: entity work.DIG_Neg
    generic map (
      Bits => 16)
    port map (
      p_in  => s2,
      p_out => s63);
                 s59 <= (s2 and s7);
                 s60 <= (s2 or s7);
                 s61 <= (s2 xor s7);
  gate21: entity work.DIG_Mul_unsigned
    generic map (
      Bits => 16)
    port map (
      a   => s2,
      b   => s7,
      mul => s76);
                 s69 <= s76(15 downto 0);
  gate22: entity work.DIG_RAMDualPort -- mem
  generic map (
    Bits     => 16,
    AddrBits => 8) port map (
    A   => s10,
    Din => s1,
    str => st,
    C   => clk,
    ld  => ld,
    D   => s11);
  gate23: entity work.MUX_GATE_2
    port map (
      sel   => s15,
      in_0  => '0',
      in_1  => s16,
      in_2  => s17,
      in_3  => s18,
      p_out => s19);
                 s20 <= (s19 xor br(2));
  gate24: entity work.DIG_Register -- Carry
    port map (
    D  => s21,
    C  => clk,
    en => sf,
    Q  => s16);
  gate25: entity work.DIG_Register -- Zero
  port map (
    D  => s22,
    C  => clk,
    en => sf,
    Q  => s17);
  gate26: entity work.DIG_Register -- Neg
  port map (
    D  => s23,
    C  => clk,
    en => sf,
    Q  => s18);
  gate27: entity work.DIG_Register -- inter1
  port map (
    D  => intr,
    C  => clk,
    en => sf,
    Q  => interEn);
                 intr <= (not InterLock and not imm and s24 and not interEn);
                 s25  <= ((InterLock and not Reti) or intr);
  gate28: entity work.DIG_Add -- Add ALU
  generic map (
    Bits => 8) port map (
    a   => s32,
    b   => s33,
    c_i => '0',
    s   => s34);
  gate29: entity work.MUX_GATE_BUS_1
    generic map (
      Bits => 8)
    port map (
      sel   => s20,
      in_0  => s32,
      in_1  => s34,
      p_out => s35);
  gate30: entity work.MUX_GATE_BUS_1
    generic map (
      Bits => 8)
    port map (
      sel   => p_abs,
      in_0  => s35,
      in_1  => s33,
      p_out => s36);
  gate31: entity work.MUX_GATE_BUS_1
    generic map (
      Bits => 8)
    port map (
      sel   => Reti,
      in_0  => s37,
      in_1  => s39,
      p_out => s30);
                 s41 <= (s40 and ioW);
  gate32: entity work.DIG_Register_BUS
    generic map (
      Bits => 8)
    port map (
      D  => s42,
      C  => clk,
      en => s41,
      Q  => uo_out);
  gate33: entity work.MUX_GATE_BUS_4
    generic map (
      Bits => 16)
    port map (
      sel   => sel,
      in_0  => s7,
      in_1  => s57,
      in_2  => s58,
      in_3  => s59,
      in_4  => s60,
      in_5  => s61,
      in_6  => s62,
      in_7  => s63,
      in_8  => s64,
      in_9  => s65,
      in_10 => s66,
      in_11 => s67,
      in_12 => s68,
      in_13 => s69,
      in_14 => "0000000000000000",
      in_15 => "0000000000000000",
      p_out => s12);
  gate34: entity work.DIG_Add
    generic map (
      Bits => 16)
    port map (
      a   => s2,
      b   => s7,
      c_i => s70,
      s   => s57,
      c_o => s71);
  gate35: entity work.DIG_Sub
    generic map (
      Bits => 16)
    port map (
      a   => s2,
      b   => s7,
      c_i => s70,
      s   => s58,
      c_o => s72);
  gate36: entity work.MUX_GATE_4
    port map (
      sel   => sel,
      in_0  => '0',
      in_1  => s71,
      in_2  => s72,
      in_3  => '0',
      in_4  => '0',
      in_5  => '0',
      in_6  => '0',
      in_7  => '0',
      in_8  => s73,
      in_9  => s74,
      in_10 => s75,
      in_11 => '0',
      in_12 => '0',
      in_13 => '0',
      in_14 => '0',
      in_15 => '0',
      p_out => s21);
                 s70 <= (aluOp(4) and s16);
  gate37: entity work.LSL
      port map (
      Di => s2,
      Ci => s70,
      Do => s64,
      Co => s73);
  gate38: entity work.LSR
    port map (
      Di => s2,
      Ci => s70,
      Do => s65,
      Co => s74);
  gate39: entity work.DIG_Register_BUS -- seed
  generic map (
    Bits => 16) port map (
    D  => s1,
    C  => clk,
    en => s81,
    Q  => s82);
                 s81                  <= (s84 and ioW);
                 FlagOut(0)           <= s16;
                 FlagOut(1)           <= s17;
                 FlagOut(2)           <= s18;
                 FlagOut(3)           <= interEn;
                 FlagOut(15 downto 4) <= "000000000000";
  gate40: entity work.MUX_GATE_BUS_1
    generic map (
      Bits => 8)
    port map (
      sel   => intr,
      in_0  => s36,
      in_1  => "00000010",
      p_out => s37);
  gate41: entity work.COMP_GATE_UNSIGNED
    generic map (
      Bits => 16)
    port map (
      a  => s12,
      b  => "0000000000000101",
      eq => s40);
  gate42: entity work.COMP_GATE_SIGNED
    generic map (
      Bits => 16)
    port map (
      a  => s12,
      b  => "0000000000000000",
      eq => s22);
  gate43: entity work.MUX_GATE_BUS_1
    generic map (
      Bits => 16)
    port map (
      sel   => s81,
      in_0  => "0000000000000000",
      in_1  => s82,
      p_out => s83);
  gate44: entity work.COMP_GATE_UNSIGNED
    generic map (
      Bits => 16)
    port map (
      a  => s12,
      b  => "0000000000001000",
      eq => s84);
                 s78  <= (clk and s81);
                 s10  <= s12(7 downto 0);
                 s23  <= s12(15);
                 s33  <= s12(7 downto 0);
                 s87  <= s83(0);
                 s90  <= s83(1);
                 s92  <= s83(2);
                 s94  <= s83(3);
                 s96  <= s83(4);
                 s98  <= s83(5);
                 s100 <= s83(6);
                 s102 <= s83(7);
                 s104 <= s83(8);
                 s106 <= s83(9);
                 s108 <= s83(10);
                 s110 <= s83(11);
                 s112 <= s83(12);
                 s114 <= s83(13);
                 s116 <= s83(14);
                 s118 <= s83(15);
  gate45: entity work.DIG_D_FF_AS
      port map (
      Set  => '0',
      D    => s77,
      C    => s78,
      Clr  => s79,
      Q    => s80,
      notQ => s77);
                 s86 <= (s81 and not s85);
  gate46: entity work.DIG_D_FF_AS
      port map (
      Set => s87,
      D   => s88,
      C   => clk,
      Clr => s86,
      Q   => s89);
  gate47: entity work.DIG_D_FF_AS
    port map (
      Set => s90,
      D   => s89,
      C   => clk,
      Clr => s86,
      Q   => s91);
  gate48: entity work.DIG_D_FF_AS
    port map (
      Set => s92,
      D   => s91,
      C   => clk,
      Clr => s86,
      Q   => s93);
  gate49: entity work.DIG_D_FF_AS
    port map (
      Set => s94,
      D   => s93,
      C   => clk,
      Clr => s86,
      Q   => s95);
  gate50: entity work.DIG_D_FF_AS
    port map (
      Set => s96,
      D   => s95,
      C   => clk,
      Clr => s86,
      Q   => s97);
  gate51: entity work.DIG_D_FF_AS
    port map (
      Set => s98,
      D   => s97,
      C   => clk,
      Clr => s86,
      Q   => s99);
  gate52: entity work.DIG_D_FF_AS
    port map (
      Set => s100,
      D   => s99,
      C   => clk,
      Clr => s86,
      Q   => s101);
  gate53: entity work.DIG_D_FF_AS
    port map (
      Set => s102,
      D   => s101,
      C   => clk,
      Clr => s86,
      Q   => s103);
  gate54: entity work.DIG_D_FF_AS
    port map (
      Set => s104,
      D   => s103,
      C   => clk,
      Clr => s86,
      Q   => s105);
  gate55: entity work.DIG_D_FF_AS
    port map (
      Set => s106,
      D   => s105,
      C   => clk,
      Clr => s86,
      Q   => s107);
  gate56: entity work.DIG_D_FF_AS
    port map (
      Set => s108,
      D   => s107,
      C   => clk,
      Clr => s86,
      Q   => s109);
  gate57: entity work.DIG_D_FF_AS
    port map (
      Set => s110,
      D   => s109,
      C   => clk,
      Clr => s86,
      Q   => s111);
  gate58: entity work.DIG_D_FF_AS
    port map (
      Set => s112,
      D   => s111,
      C   => clk,
      Clr => s86,
      Q   => s113);
  gate59: entity work.DIG_D_FF_AS
    port map (
      Set => s114,
      D   => s113,
      C   => clk,
      Clr => s86,
      Q   => s115);
  gate60: entity work.DIG_D_FF_AS
    port map (
      Set => s116,
      D   => s115,
      C   => clk,
      Clr => s86,
      Q   => s117);
  gate61: entity work.DIG_D_FF_AS
    port map (
      Set => s118,
      D   => s117,
      C   => clk,
      Clr => s86,
      Q   => s119);
                 s88           <= (s99 xor (s109 xor (s113 xor s117)));
                 RandomNUM(0)  <= s89;
                 RandomNUM(1)  <= s91;
                 RandomNUM(2)  <= s93;
                 RandomNUM(3)  <= s95;
                 RandomNUM(4)  <= s97;
                 RandomNUM(5)  <= s99;
                 RandomNUM(6)  <= s101;
                 RandomNUM(7)  <= s103;
                 RandomNUM(8)  <= s105;
                 RandomNUM(9)  <= s107;
                 RandomNUM(10) <= s109;
                 RandomNUM(11) <= s111;
                 RandomNUM(12) <= s113;
                 RandomNUM(13) <= s115;
                 RandomNUM(14) <= s117;
                 RandomNUM(15) <= s119;
                 s85           <= (s80 or s79);
  gate62: entity work.DIG_JK_FF
    generic map (
      tempVar => '0')
    port map (
      J => s85,
      C => clk,
      K => s85,
      Q => s79);
  uio_out <= uio_oe_temp;
  uio_oe  <= uio_oe_temp;
end architecture;
