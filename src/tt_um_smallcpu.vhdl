-- generated by Digital. Don't modify this file!
-- Any changes will be lost if this file is regenerated.

LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.numeric_std.all;

entity DIG_Counter is
  port (
    p_out: out std_logic_vector((2-1) downto 0);
    ovf: out std_logic;
    C: in std_logic;
    en: in std_logic;
    clr: in std_logic );
end DIG_Counter;

architecture Behavioral of DIG_Counter is
   signal count : std_logic_vector((2-1) downto 0) := (others => '0');
begin
    process (C, clr, en)
    begin
      if rising_edge(C) then
        if clr='1' then
          count <= (others => '0');
        elsif en='1' then
          count <=  std_logic_vector(unsigned(count) + 1);
        end if;
      end if;
    end process;

    p_out <= count;
    ovf <= en when unsigned(count) = ((2**2)-1) else '0';
end Behavioral;


LIBRARY ieee;
USE ieee.std_logic_1164.all;

entity DIG_Register_BUS is
  generic ( Bits: integer ); 
  port (
    Q: out std_logic_vector ((Bits-1) downto 0);
    D: in std_logic_vector ((Bits-1) downto 0);
    C: in std_logic;
    en: in std_logic );
end DIG_Register_BUS;

architecture Behavioral of DIG_Register_BUS is
  signal state : std_logic_vector ((Bits-1) downto 0) := (others => '0');
begin
   Q <= state;

   process ( C )
   begin
      if rising_edge(C) and (en='1') then
        state <= D;
      end if;
   end process;
end Behavioral;


LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.numeric_std.all;

entity singExtend is
  port (
    inst: in std_logic_vector(15 downto 0); -- instruction word
    n4S: out std_logic_vector(15 downto 0); -- The four bits taken from Rs.
    n8SD: out std_logic_vector(15 downto 0); -- The eight bits taken from Rs,Rd with sign extension.
    n4D: out std_logic_vector(15 downto 0) -- The four bits taken from Rd.
    );
end singExtend;

architecture Behavioral of singExtend is
  signal s0: std_logic;
begin
  n4D(3 downto 0) <= inst(7 downto 4);
  n4D(15 downto 4) <= "000000000000";
  n4S(3 downto 0) <= inst(3 downto 0);
  n4S(15 downto 4) <= "000000000000";
  s0 <= inst(7);
  n8SD(6 downto 0) <= inst(6 downto 0);
  n8SD(7) <= s0;
  n8SD(8) <= s0;
  n8SD(9) <= s0;
  n8SD(10) <= s0;
  n8SD(11) <= s0;
  n8SD(12) <= s0;
  n8SD(13) <= s0;
  n8SD(14) <= s0;
  n8SD(15) <= s0;
end Behavioral;

LIBRARY ieee;
USE ieee.std_logic_1164.all;

entity MUX_GATE_BUS_1 is
  generic ( Bits : integer ); 
  port (
    p_out: out std_logic_vector ((Bits-1) downto 0);
    sel: in std_logic;
    
    in_0: in std_logic_vector ((Bits-1) downto 0);
    in_1: in std_logic_vector ((Bits-1) downto 0) );
end MUX_GATE_BUS_1;

architecture Behavioral of MUX_GATE_BUS_1 is
begin
  with sel select
    p_out <=
      in_0 when '0',
      in_1 when '1',
      (others => '0') when others;
end Behavioral;


LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.numeric_std.all;

entity controllogic is
  port (
    A: in std_logic;
    B: in std_logic;
    C: in std_logic;
    D: in std_logic;
    E: in std_logic;
    F: in std_logic;
    G: in std_logic;
    muxb0: out std_logic;
    muxb1: out std_logic;
    muxb2: out std_logic;
    src2D: out std_logic;
    aluop0: out std_logic;
    aluop1: out std_logic;
    aluop2: out std_logic;
    aluop3: out std_logic;
    aluop4: out std_logic;
    WE: out std_logic;
    sf: out std_logic;
    alu2D: out std_logic;
    iem0: out std_logic;
    iem1: out std_logic;
    br0: out std_logic;
    br1: out std_logic;
    br2: out std_logic;
    muxA: out std_logic;
    ld: out std_logic;
    st: out std_logic;
    p_abs: out std_logic;
    ioW: out std_logic;
    ioR: out std_logic;
    stPC: out std_logic;
    Reti: out std_logic;
    rand: out std_logic);
end controllogic;

architecture Behavioral of controllogic is
  signal s0: std_logic;
  signal s1: std_logic;
  signal s2: std_logic;
  signal s3: std_logic;
  signal s4: std_logic;
  signal s5: std_logic;
  signal s6: std_logic;
begin
  s5 <= NOT A;
  s0 <= NOT B;
  s1 <= NOT C;
  s2 <= NOT D;
  s3 <= NOT E;
  s6 <= NOT F;
  s4 <= NOT G;
  muxb0 <= ((A AND s0 AND s1 AND s2 AND s3 AND F AND s4) OR (A AND s0 AND s1 AND s2 AND E AND F AND G) OR (s5 AND s1 AND D AND E AND F AND s4) OR (s5 AND B AND C AND s3 AND s6 AND s4) OR (s5 AND s0 AND s1 AND D AND F AND s4) OR (s5 AND s0 AND s1 AND D AND E AND s4) OR (s5 AND s0 AND C AND s2 AND s3 AND s4) OR (s5 AND B AND s1 AND s2 AND s3 AND G) OR (s5 AND C AND D AND s6 AND G) OR (s5 AND C AND s2 AND E AND G) OR (s5 AND B AND C AND E AND G) OR (s5 AND B AND C AND s2 AND E));
  muxb1 <= ((A AND s0 AND s1 AND s2 AND E AND F AND s4) OR (s5 AND C AND s2 AND s3 AND s6 AND G) OR (s5 AND B AND s1 AND s2 AND s3 AND s4) OR (A AND s0 AND s1 AND s2 AND s3 AND G) OR (A AND s0 AND s1 AND s2 AND s3 AND s6) OR (s5 AND s1 AND D AND F AND G) OR (s5 AND C AND D AND s6 AND s4) OR (s5 AND B AND C AND s6 AND G) OR (s5 AND B AND C AND F AND s4) OR (s5 AND C AND s2 AND E AND s4) OR (s5 AND s0 AND s1 AND D AND G) OR (s5 AND B AND D AND E) OR (s5 AND B AND C AND E));
  muxb2 <= ((s5 AND B AND C AND D AND E AND F AND G) OR (s5 AND C AND s2 AND s3 AND s6 AND s4) OR (s5 AND B AND s2 AND s3 AND F AND G) OR (s5 AND B AND s1 AND s3 AND F AND G) OR (s5 AND s0 AND s1 AND D AND F AND s4) OR (s5 AND s0 AND C AND D AND s6 AND G) OR (A AND s0 AND s1 AND s2 AND F AND G) OR (s5 AND s0 AND C AND s2 AND s3 AND s4) OR (s5 AND s0 AND C AND s2 AND E AND G) OR (s5 AND B AND s1 AND s2 AND s3 AND G) OR (A AND s0 AND s1 AND s2 AND s3 AND s4) OR (s5 AND s1 AND D AND E AND s4));
  src2D <= ((s5 AND s0 AND s1 AND s2 AND s3 AND s6 AND G) OR (s5 AND B AND s1 AND D AND s3 AND F AND G) OR (s5 AND B AND s1 AND D AND E AND s6 AND G) OR (s5 AND B AND C AND s2 AND s3 AND s6 AND G) OR (A AND s0 AND s1 AND s2 AND s3 AND s6 AND s4) OR (s5 AND B AND D AND E AND F AND s4) OR (s5 AND B AND C AND D AND E AND F));
  aluop0 <= ((s5 AND s0 AND s1 AND D AND E AND F AND s4) OR (s5 AND s0 AND C AND s2 AND s3 AND s6 AND G) OR (s5 AND s0 AND C AND s2 AND s3 AND F AND s4) OR (s5 AND s0 AND C AND D AND E AND F AND G) OR (s5 AND s1 AND s2 AND s3 AND F AND G) OR (s5 AND s0 AND s1 AND E AND s6 AND G) OR (s5 AND B AND s1 AND s2 AND F));
  aluop1 <= ((s5 AND s0 AND C AND D AND s3 AND F AND G) OR (A AND s0 AND s1 AND s2 AND E AND s6 AND G) OR (A AND s0 AND s1 AND s2 AND E AND F AND s4) OR (s5 AND B AND s1 AND D AND s3 AND s4) OR (s5 AND s0 AND C AND D AND E AND s6) OR (s5 AND B AND s1 AND D AND s3 AND s6) OR (s5 AND B AND s1 AND s2 AND E));
  aluop2 <= ((s5 AND B AND s1 AND D AND s3 AND F AND s4) OR (A AND s0 AND s1 AND s2 AND E AND s6 AND G) OR (A AND s0 AND s1 AND s2 AND E AND F AND s4) OR (s5 AND s0 AND s2 AND E AND F AND G) OR (s5 AND s0 AND D AND s3 AND s6 AND s4) OR (s5 AND s0 AND C AND s3 AND F AND G) OR (s5 AND s0 AND C AND s2 AND E AND F) OR (s5 AND s0 AND C AND D AND s6) OR (s5 AND s0 AND C AND D AND s3));
  aluop3 <= ((s5 AND s0 AND D AND E AND F AND G) OR (s5 AND s0 AND C AND D AND F AND s4) OR (s5 AND s0 AND s2 AND E AND s6) OR (s5 AND B AND s1 AND s3 AND s6) OR (s5 AND s0 AND C AND s2 AND s3) OR (s5 AND B AND s1 AND s2 AND s3) OR (s0 AND s1 AND s2 AND E AND s6 AND G) OR (s0 AND s1 AND s2 AND E AND F AND s4));
  aluop4 <= ((s5 AND B AND C AND s2 AND s3 AND s6 AND G) OR (s5 AND B AND C AND s2 AND s3 AND F AND s4) OR (A AND s0 AND s1 AND s2 AND s3 AND s6 AND s4) OR (s5 AND s1 AND D AND E AND s6 AND s4) OR (s5 AND s0 AND s1 AND E AND F AND s4) OR (s5 AND s0 AND s1 AND s2 AND F AND s4) OR (s5 AND s0 AND C AND D AND s3 AND G) OR (s5 AND B AND s1 AND s2 AND E AND G) OR (s5 AND B AND s1 AND D AND s3 AND G) OR (s5 AND s0 AND s3 AND F AND G) OR (s5 AND s0 AND D AND s6 AND s4) OR (s5 AND s0 AND D AND E AND s6) OR (s5 AND s0 AND C AND E AND s6) OR (s0 AND s1 AND s2 AND s3 AND F AND G));
  WE <= ((s5 AND D AND s3 AND F AND s4) OR (s5 AND s1 AND E AND s6 AND s4) OR (s5 AND s1 AND E AND F AND G) OR (s5 AND C AND s2 AND s3 AND s4) OR (s5 AND s1 AND D AND s3 AND s6) OR (s5 AND C AND s2 AND s3 AND F) OR (s5 AND s0 AND D AND s6) OR (s5 AND s1 AND s2 AND E) OR (s5 AND s0 AND D AND s3) OR (s5 AND s0 AND s1 AND D) OR (s5 AND s0 AND C AND s2) OR (s0 AND s1 AND s2 AND G) OR (s0 AND s1 AND s2 AND F));
  sf <= ((s5 AND s1 AND D AND s3 AND s6 AND s4) OR (s5 AND s0 AND s2 AND F AND s4) OR (s5 AND s0 AND D AND F AND G) OR (s5 AND s0 AND s1 AND F AND G) OR (s5 AND s0 AND C AND s6) OR (s5 AND B AND s1 AND s2) OR (s5 AND s0 AND E) OR (s0 AND s1 AND s2 AND E AND s6 AND G) OR (s0 AND s1 AND s2 AND E AND F AND s4));
  alu2D <= ((s5 AND C AND s2 AND s3 AND F AND G) OR (s5 AND s1 AND D AND s3 AND s4) OR (s5 AND s1 AND D AND s3 AND s6) OR (s5 AND s0 AND E AND s6) OR (s5 AND s0 AND s2 AND F) OR (s5 AND s0 AND s1 AND F) OR (s5 AND s1 AND s2 AND E) OR (s5 AND s0 AND C AND s3) OR (s0 AND s1 AND s2 AND E AND s6 AND G) OR (s0 AND s1 AND s2 AND E AND F AND s4));
  iem0 <= ((s5 AND s0 AND C AND s2 AND s3 AND s6 AND G) OR (A AND s0 AND s1 AND s2 AND s3 AND s6 AND G) OR (A AND s0 AND s1 AND s2 AND E AND F AND s4) OR (s5 AND C AND D AND E AND s6 AND s4) OR (s5 AND s0 AND C AND D AND s6 AND s4) OR (s5 AND B AND C AND D AND F AND s4) OR (s5 AND s0 AND C AND s2 AND E AND s4) OR (s5 AND B AND s1 AND s2 AND s3 AND s4) OR (s5 AND s1 AND D AND E AND G) OR (s5 AND s0 AND s1 AND D AND G));
  iem1 <= ((s5 AND B AND s1 AND D AND E AND s6 AND G) OR (s5 AND B AND C AND D AND E AND F AND s4));
  br0 <= ((s5 AND B AND C AND s2 AND E AND F AND G) OR (s5 AND B AND C AND D AND s6 AND G) OR (s5 AND B AND C AND D AND s3 AND s6));
  br1 <= ((s5 AND B AND C AND s2 AND E AND s6 AND G) OR (s5 AND B AND C AND s2 AND E AND F AND s4) OR (s5 AND B AND C AND D AND s3 AND s6));
  br2 <= ((s5 AND B AND C AND D AND s3 AND s6 AND G) OR (s5 AND B AND C AND s2 AND E AND s4) OR (s5 AND B AND C AND s2 AND E AND F));
  muxA <= ((s5 AND B AND s1 AND D AND E AND s6 AND s4) OR (s5 AND B AND C AND s2 AND s3 AND F AND s4) OR (A AND s0 AND s1 AND s2 AND s3 AND G) OR (A AND s0 AND s1 AND s2 AND s3 AND F));
  ld <= ((s5 AND B AND s1 AND D AND E AND s6 AND s4) OR (s5 AND B AND s1 AND D AND E AND F AND G) OR (s5 AND B AND C AND s2 AND s3 AND s4));
  st <= ((s5 AND B AND s1 AND D AND s3 AND F AND G) OR (s5 AND B AND s1 AND D AND E AND s6 AND G) OR (s5 AND B AND s1 AND D AND E AND F AND s4) OR (s5 AND B AND C AND s2 AND s3 AND s6 AND G));
  p_abs <= ((s5 AND B AND C AND D AND E AND s6 AND s4) OR (A AND s0 AND s1 AND s2 AND E AND s6 AND s4) OR (s5 AND B AND C AND D AND s3 AND F));
  ioW <= ((A AND s0 AND s1 AND s2 AND s3 AND s6 AND s4) OR (s5 AND B AND C AND D AND E AND F));
  ioR <= ((A AND s0 AND s1 AND s2 AND s3 AND G) OR (A AND s0 AND s1 AND s2 AND s3 AND F));
  stPC <= (s5 AND B AND C AND D AND s3 AND F AND s4);
  Reti <= (A AND s0 AND s1 AND s2 AND E AND s6 AND s4);
  rand <= (A AND s0 AND s1 AND s2 AND E AND F AND G);
end Behavioral;

LIBRARY ieee;
USE ieee.std_logic_1164.all;

entity MUX_GATE_2 is
  port (
    p_out: out std_logic;
    sel: in std_logic_vector (1 downto 0);
    
    in_0: in std_logic;
    in_1: in std_logic;
    in_2: in std_logic;
    in_3: in std_logic );
end MUX_GATE_2;

architecture Behavioral of MUX_GATE_2 is
begin
  with sel select
    p_out <=
      in_0 when "00",
      in_1 when "01",
      in_2 when "10",
      in_3 when "11",
      '0' when others;
end Behavioral;


LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.numeric_std.all;

-- Register for storing large constants.
-- There is a 1-bit command describing this register. 
-- In this way, 15 bits can be stored (the 16th bit 
-- activates the writing of this register and therefore 
-- is always one). The 16th bit will be set according 
-- to the 'immediate extend mode' (iem).
entity ImReg is
  port (
    en: in std_logic; -- enables storage
    iem: in std_logic_vector(1 downto 0); -- immediate extend mode (0: sign extend; 1: extend with 0, 2:extend with S0, 3:extend with D0)
    C: in std_logic;
    inst: in std_logic_vector(15 downto 0); -- the current instruction
    imm: out std_logic_vector(15 downto 0) -- The constant of register contents and bit 8.
    );
end ImReg;

architecture Behavioral of ImReg is
  signal s0: std_logic_vector(14 downto 0);
  signal s1: std_logic_vector(14 downto 0);
  signal s2: std_logic;
  signal s3: std_logic;
  signal s4: std_logic;
  signal s5: std_logic;
begin
  s2 <= inst(0);
  s3 <= inst(4);
  s0 <= inst(14 downto 0);
  gate0: entity work.DIG_Register_BUS -- imm
    generic map (
      Bits => 15)
    port map (
      D => s0,
      C => C,
      en => en,
      Q => s1);
  s5 <= s1(14);
  gate1: entity work.MUX_GATE_2
    port map (
      sel => iem,
      in_0 => s5,
      in_1 => '0',
      in_2 => s2,
      in_3 => s3,
      p_out => s4);
  imm(14 downto 0) <= s1;
  imm(15) <= s4;
end Behavioral;

LIBRARY ieee;
USE ieee.std_logic_1164.all;

entity MUX_GATE_BUS_3 is
  generic ( Bits : integer ); 
  port (
    p_out: out std_logic_vector ((Bits-1) downto 0);
    sel: in std_logic_vector (2 downto 0);
    
    in_0: in std_logic_vector ((Bits-1) downto 0);
    in_1: in std_logic_vector ((Bits-1) downto 0);
    in_2: in std_logic_vector ((Bits-1) downto 0);
    in_3: in std_logic_vector ((Bits-1) downto 0);
    in_4: in std_logic_vector ((Bits-1) downto 0);
    in_5: in std_logic_vector ((Bits-1) downto 0);
    in_6: in std_logic_vector ((Bits-1) downto 0);
    in_7: in std_logic_vector ((Bits-1) downto 0) );
end MUX_GATE_BUS_3;

architecture Behavioral of MUX_GATE_BUS_3 is
begin
  with sel select
    p_out <=
      in_0 when "000",
      in_1 when "001",
      in_2 when "010",
      in_3 when "011",
      in_4 when "100",
      in_5 when "101",
      in_6 when "110",
      in_7 when "111",
      (others => '0') when others;
end Behavioral;


LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.numeric_std.all;

entity DIG_RAMDualPort is
  generic (
    Bits : integer;       
    AddrBits : integer ); 
  port (
    D: out std_logic_vector ((Bits-1) downto 0);
    A: in std_logic_vector ((AddrBits-1) downto 0);
    Din: in std_logic_vector ((Bits-1) downto 0);
    str: in std_logic;
    C: in std_logic;
    ld: in std_logic );
end DIG_RAMDualPort;

architecture Behavioral of DIG_RAMDualPort is
    -- CAUTION: uses distributed RAM
    type memoryType is array(0 to (2**AddrBits)-1) of STD_LOGIC_VECTOR((Bits-1) downto 0);
    signal memory : memoryType;
begin
  process ( C )
  begin
    if rising_edge(C) AND (str='1') then
      memory(to_integer(unsigned(A))) <= Din;
    end if;
  end process;
  D <= memory(to_integer(unsigned(A))) when ld='1' else (others => 'Z');
end Behavioral;


LIBRARY ieee;
USE ieee.std_logic_1164.all;

entity DIG_Register is
  
  port (
    Q: out std_logic;
    D: in std_logic;
    C: in std_logic;
    en: in std_logic );
end DIG_Register;

architecture Behavioral of DIG_Register is
  signal state : std_logic := '0';
begin
   Q <= state;

   process ( C )
   begin
      if rising_edge(C) and (en='1') then
        state <= D;
      end if;
   end process;
end Behavioral;


LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.numeric_std.all;

entity DEMUX_GATE_4 is
  generic (
    tempvar : integer );
  port (
    out_0: out std_logic;
    out_1: out std_logic;
    out_2: out std_logic;
    out_3: out std_logic;
    out_4: out std_logic;
    out_5: out std_logic;
    out_6: out std_logic;
    out_7: out std_logic;
    out_8: out std_logic;
    out_9: out std_logic;
    out_10: out std_logic;
    out_11: out std_logic;
    out_12: out std_logic;
    out_13: out std_logic;
    out_14: out std_logic;
    out_15: out std_logic;
    sel: in std_logic_vector (3 downto 0);
    p_in: in std_logic );
end DEMUX_GATE_4;

architecture Behavioral of DEMUX_GATE_4 is
begin
    out_0 <= p_in when sel = "0000" else std_logic(to_unsigned(tempvar, 1)(0));
    out_1 <= p_in when sel = "0001" else std_logic(to_unsigned(tempvar, 1)(0));
    out_2 <= p_in when sel = "0010" else std_logic(to_unsigned(tempvar, 1)(0));
    out_3 <= p_in when sel = "0011" else std_logic(to_unsigned(tempvar, 1)(0));
    out_4 <= p_in when sel = "0100" else std_logic(to_unsigned(tempvar, 1)(0));
    out_5 <= p_in when sel = "0101" else std_logic(to_unsigned(tempvar, 1)(0));
    out_6 <= p_in when sel = "0110" else std_logic(to_unsigned(tempvar, 1)(0));
    out_7 <= p_in when sel = "0111" else std_logic(to_unsigned(tempvar, 1)(0));
    out_8 <= p_in when sel = "1000" else std_logic(to_unsigned(tempvar, 1)(0));
    out_9 <= p_in when sel = "1001" else std_logic(to_unsigned(tempvar, 1)(0));
    out_10 <= p_in when sel = "1010" else std_logic(to_unsigned(tempvar, 1)(0));
    out_11 <= p_in when sel = "1011" else std_logic(to_unsigned(tempvar, 1)(0));
    out_12 <= p_in when sel = "1100" else std_logic(to_unsigned(tempvar, 1)(0));
    out_13 <= p_in when sel = "1101" else std_logic(to_unsigned(tempvar, 1)(0));
    out_14 <= p_in when sel = "1110" else std_logic(to_unsigned(tempvar, 1)(0));
    out_15 <= p_in when sel = "1111" else std_logic(to_unsigned(tempvar, 1)(0));
end Behavioral;


LIBRARY ieee;
USE ieee.std_logic_1164.all;

entity MUX_GATE_BUS_4 is
  generic ( Bits : integer ); 
  port (
    p_out: out std_logic_vector ((Bits-1) downto 0);
    sel: in std_logic_vector (3 downto 0);
    
    in_0: in std_logic_vector ((Bits-1) downto 0);
    in_1: in std_logic_vector ((Bits-1) downto 0);
    in_2: in std_logic_vector ((Bits-1) downto 0);
    in_3: in std_logic_vector ((Bits-1) downto 0);
    in_4: in std_logic_vector ((Bits-1) downto 0);
    in_5: in std_logic_vector ((Bits-1) downto 0);
    in_6: in std_logic_vector ((Bits-1) downto 0);
    in_7: in std_logic_vector ((Bits-1) downto 0);
    in_8: in std_logic_vector ((Bits-1) downto 0);
    in_9: in std_logic_vector ((Bits-1) downto 0);
    in_10: in std_logic_vector ((Bits-1) downto 0);
    in_11: in std_logic_vector ((Bits-1) downto 0);
    in_12: in std_logic_vector ((Bits-1) downto 0);
    in_13: in std_logic_vector ((Bits-1) downto 0);
    in_14: in std_logic_vector ((Bits-1) downto 0);
    in_15: in std_logic_vector ((Bits-1) downto 0) );
end MUX_GATE_BUS_4;

architecture Behavioral of MUX_GATE_BUS_4 is
begin
  with sel select
    p_out <=
      in_0 when "0000",
      in_1 when "0001",
      in_2 when "0010",
      in_3 when "0011",
      in_4 when "0100",
      in_5 when "0101",
      in_6 when "0110",
      in_7 when "0111",
      in_8 when "1000",
      in_9 when "1001",
      in_10 when "1010",
      in_11 when "1011",
      in_12 when "1100",
      in_13 when "1101",
      in_14 when "1110",
      in_15 when "1111",
      (others => '0') when others;
end Behavioral;


LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.numeric_std.all;

entity RegisterBlock is
  port (
    DataIn: in std_logic_vector(15 downto 0);
    WE: in std_logic;
    clk: in std_logic;
    src: in std_logic_vector(3 downto 0);
    Dest: in std_logic_vector(3 downto 0);
    RDest: out std_logic_vector(15 downto 0);
    Rsrc: out std_logic_vector(15 downto 0));
end RegisterBlock;

architecture Behavioral of RegisterBlock is
  signal s0: std_logic;
  signal s1: std_logic_vector(15 downto 0);
  signal s2: std_logic;
  signal s3: std_logic_vector(15 downto 0);
  signal s4: std_logic;
  signal s5: std_logic_vector(15 downto 0);
  signal s6: std_logic;
  signal s7: std_logic_vector(15 downto 0);
  signal s8: std_logic;
  signal s9: std_logic_vector(15 downto 0);
  signal s10: std_logic;
  signal s11: std_logic_vector(15 downto 0);
  signal s12: std_logic;
  signal s13: std_logic_vector(15 downto 0);
  signal s14: std_logic;
  signal s15: std_logic_vector(15 downto 0);
  signal s16: std_logic;
  signal s17: std_logic_vector(15 downto 0);
  signal s18: std_logic;
  signal s19: std_logic_vector(15 downto 0);
  signal s20: std_logic;
  signal s21: std_logic_vector(15 downto 0);
  signal s22: std_logic;
  signal s23: std_logic_vector(15 downto 0);
  signal s24: std_logic;
  signal s25: std_logic_vector(15 downto 0);
  signal s26: std_logic;
  signal s27: std_logic_vector(15 downto 0);
  signal s28: std_logic;
  signal s29: std_logic_vector(15 downto 0);
  signal s30: std_logic;
  signal s31: std_logic_vector(15 downto 0);
begin
  gate0: entity work.DEMUX_GATE_4
    generic map (
      tempvar => 0)
    port map (
      sel => Dest,
      p_in => WE,
      out_0 => s0,
      out_1 => s2,
      out_2 => s4,
      out_3 => s6,
      out_4 => s8,
      out_5 => s10,
      out_6 => s12,
      out_7 => s14,
      out_8 => s16,
      out_9 => s18,
      out_10 => s20,
      out_11 => s22,
      out_12 => s24,
      out_13 => s26,
      out_14 => s28,
      out_15 => s30);
  gate1: entity work.DIG_Register_BUS -- R0
    generic map (
      Bits => 16)
    port map (
      D => DataIn,
      C => clk,
      en => s0,
      Q => s1);
  gate2: entity work.DIG_Register_BUS -- R1
    generic map (
      Bits => 16)
    port map (
      D => DataIn,
      C => clk,
      en => s2,
      Q => s3);
  gate3: entity work.DIG_Register_BUS -- R2
    generic map (
      Bits => 16)
    port map (
      D => DataIn,
      C => clk,
      en => s4,
      Q => s5);
  gate4: entity work.DIG_Register_BUS -- R3
    generic map (
      Bits => 16)
    port map (
      D => DataIn,
      C => clk,
      en => s6,
      Q => s7);
  gate5: entity work.DIG_Register_BUS -- R4
    generic map (
      Bits => 16)
    port map (
      D => DataIn,
      C => clk,
      en => s8,
      Q => s9);
  gate6: entity work.DIG_Register_BUS -- R5
    generic map (
      Bits => 16)
    port map (
      D => DataIn,
      C => clk,
      en => s10,
      Q => s11);
  gate7: entity work.DIG_Register_BUS -- R6
    generic map (
      Bits => 16)
    port map (
      D => DataIn,
      C => clk,
      en => s12,
      Q => s13);
  gate8: entity work.DIG_Register_BUS -- R7
    generic map (
      Bits => 16)
    port map (
      D => DataIn,
      C => clk,
      en => s14,
      Q => s15);
  gate9: entity work.DIG_Register_BUS -- R8
    generic map (
      Bits => 16)
    port map (
      D => DataIn,
      C => clk,
      en => s16,
      Q => s17);
  gate10: entity work.DIG_Register_BUS -- R9
    generic map (
      Bits => 16)
    port map (
      D => DataIn,
      C => clk,
      en => s18,
      Q => s19);
  gate11: entity work.DIG_Register_BUS -- R10
    generic map (
      Bits => 16)
    port map (
      D => DataIn,
      C => clk,
      en => s20,
      Q => s21);
  gate12: entity work.DIG_Register_BUS -- R11
    generic map (
      Bits => 16)
    port map (
      D => DataIn,
      C => clk,
      en => s22,
      Q => s23);
  gate13: entity work.DIG_Register_BUS -- R12
    generic map (
      Bits => 16)
    port map (
      D => DataIn,
      C => clk,
      en => s24,
      Q => s25);
  gate14: entity work.DIG_Register_BUS -- BP
    generic map (
      Bits => 16)
    port map (
      D => DataIn,
      C => clk,
      en => s26,
      Q => s27);
  gate15: entity work.DIG_Register_BUS -- SP
    generic map (
      Bits => 16)
    port map (
      D => DataIn,
      C => clk,
      en => s28,
      Q => s29);
  gate16: entity work.DIG_Register_BUS -- RA
    generic map (
      Bits => 16)
    port map (
      D => DataIn,
      C => clk,
      en => s30,
      Q => s31);
  gate17: entity work.MUX_GATE_BUS_4
    generic map (
      Bits => 16)
    port map (
      sel => Dest,
      in_0 => s1,
      in_1 => s3,
      in_2 => s5,
      in_3 => s7,
      in_4 => s9,
      in_5 => s11,
      in_6 => s13,
      in_7 => s15,
      in_8 => s17,
      in_9 => s19,
      in_10 => s21,
      in_11 => s23,
      in_12 => s25,
      in_13 => s27,
      in_14 => s29,
      in_15 => s31,
      p_out => RDest);
  gate18: entity work.MUX_GATE_BUS_4
    generic map (
      Bits => 16)
    port map (
      sel => src,
      in_0 => s1,
      in_1 => s3,
      in_2 => s5,
      in_3 => s7,
      in_4 => s9,
      in_5 => s11,
      in_6 => s13,
      in_7 => s15,
      in_8 => s17,
      in_9 => s19,
      in_10 => s21,
      in_11 => s23,
      in_12 => s25,
      in_13 => s27,
      in_14 => s29,
      in_15 => s31,
      p_out => Rsrc);
end Behavioral;

LIBRARY ieee;
USE ieee.std_logic_1164.all;

entity MUX_GATE_4 is
  port (
    p_out: out std_logic;
    sel: in std_logic_vector (3 downto 0);
    
    in_0: in std_logic;
    in_1: in std_logic;
    in_2: in std_logic;
    in_3: in std_logic;
    in_4: in std_logic;
    in_5: in std_logic;
    in_6: in std_logic;
    in_7: in std_logic;
    in_8: in std_logic;
    in_9: in std_logic;
    in_10: in std_logic;
    in_11: in std_logic;
    in_12: in std_logic;
    in_13: in std_logic;
    in_14: in std_logic;
    in_15: in std_logic );
end MUX_GATE_4;

architecture Behavioral of MUX_GATE_4 is
begin
  with sel select
    p_out <=
      in_0 when "0000",
      in_1 when "0001",
      in_2 when "0010",
      in_3 when "0011",
      in_4 when "0100",
      in_5 when "0101",
      in_6 when "0110",
      in_7 when "0111",
      in_8 when "1000",
      in_9 when "1001",
      in_10 when "1010",
      in_11 when "1011",
      in_12 when "1100",
      in_13 when "1101",
      in_14 when "1110",
      in_15 when "1111",
      '0' when others;
end Behavioral;


LIBRARY ieee;
USE ieee.std_logic_1164.all;

entity DIG_JK_FF is
  generic (tempvar : std_logic);  
  port (
    Q: out std_logic;
    notQ: out std_logic;
    J: in std_logic;
    C: in std_logic;
    K: in std_logic );
end DIG_JK_FF;

architecture Behavioral of DIG_JK_FF is
  signal temp: std_logic := tempvar;
begin
  process (C)
  begin
    if rising_edge(C) then
      if (J='0' and K='1') then
         temp <= '0';
      elsif (J='1' and K='0') then
         temp <= '1';
      elsif (J='1' and K='1') then
         temp <= not (temp);
      end if;
    end if;
  end process;
  Q <= temp;
  notQ <= NOT( temp );
end Behavioral;


LIBRARY ieee;
USE ieee.std_logic_1164.all;

entity DIG_D_FF_AS is
  
  port (
    Q: out std_logic;
    notQ: out std_logic;
    Set: in std_logic;
    D: in std_logic;
    C: in std_logic;
    Clr: in std_logic );
end DIG_D_FF_AS;

architecture Behavioral of DIG_D_FF_AS is
   signal state : std_logic := '0';
begin
    process (Set, Clr, C)
    begin
        if (Set='1') then
            state <= NOT('0');
        elsif (Clr='1') then
            state <= '0';
        elsif rising_edge(C) then
            state <= D;
        end if;
    end process;

    Q <= state;
    notQ <= NOT( state );
end Behavioral;


LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.numeric_std.all;
entity COMP_GATE_SIGNED is
  generic ( Bits : integer );
  port (
    gr: out std_logic;
    eq: out std_logic;
    le: out std_logic;
    a: in std_logic_vector ((Bits-1) downto 0);
    b: in std_logic_vector ((Bits-1) downto 0) );
end COMP_GATE_SIGNED;

architecture Behavioral of COMP_GATE_SIGNED is
begin
  process(a, b)
  begin
    if (signed(a) > signed(b)) then
      le <= '0';
      eq <= '0';
      gr <= '1';
    elsif (signed(a) < signed(b)) then
      le <= '1';
      eq <= '0';
      gr <= '0';
    else
      le <= '0';
      eq <= '1';
      gr <= '0';
    end if;
  end process;
end Behavioral;


LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.numeric_std.all;

-- Moves the data word to the left to higher bits, so it multiplies 
-- by two. The current carry bit is pushed in at the bottom, and 
-- the most significant bit is output as a carry bit.
entity LSL is
  port (
    Di: in std_logic_vector(15 downto 0); -- data input
    Ci: in std_logic; -- carry input
    Do: out std_logic_vector(15 downto 0); -- data output
    Co: out std_logic -- carry output
    );
end LSL;

architecture Behavioral of LSL is
begin
  Do(0) <= Ci;
  Do(15 downto 1) <= Di(14 downto 0);
  Co <= Di(15);
end Behavioral;

LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.numeric_std.all;

-- Shift right. So a division by two.
-- The carry bit is inserted at the top. And the least 
-- significant bit is output as a new carry bit.
entity LSR is
  port (
    Di: in std_logic_vector(15 downto 0); -- data input
    Ci: in std_logic; -- carry input
    Do: out std_logic_vector(15 downto 0); -- data output
    Co: out std_logic -- carry output
    );
end LSR;

architecture Behavioral of LSR is
begin
  Do(14 downto 0) <= Di(15 downto 1);
  Do(15) <= Ci;
  Co <= Di(0);
end Behavioral;

LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.numeric_std.all;

-- Arithmetic shift right. An unsigned division by two. 
-- The lower bit is output as the carry bit, while the 
-- uppermost bit remains unchanged in order to 
-- obtain the sign.
entity ASR is
  port (
    Di: in std_logic_vector(15 downto 0); -- data input
    C: out std_logic; -- carry output
    Do: out std_logic_vector(15 downto 0) -- data output
    );
end ASR;

architecture Behavioral of ASR is
  signal s0: std_logic;
begin
  C <= Di(0);
  s0 <= Di(15);
  Do(13 downto 0) <= Di(14 downto 1);
  Do(14) <= s0;
  Do(15) <= s0;
end Behavioral;

LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.numeric_std.all;

-- Swaps the high-byte and the low-byte.
entity SWAP is
  port (
    Di: in std_logic_vector(15 downto 0); -- data input
    Do: out std_logic_vector(15 downto 0) -- data output
    );
end SWAP;

architecture Behavioral of SWAP is
begin
  Do(7 downto 0) <= Di(15 downto 8);
  Do(15 downto 8) <= Di(7 downto 0);
end Behavioral;

LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.numeric_std.all;

-- Swaps the 4-bit nibble in the high- and the low-byte.
entity SWAPN is
  port (
    Di: in std_logic_vector(15 downto 0); -- Data input
    Do: out std_logic_vector(15 downto 0) -- Data output
    );
end SWAPN;

architecture Behavioral of SWAPN is
begin
  Do(3 downto 0) <= Di(7 downto 4);
  Do(7 downto 4) <= Di(3 downto 0);
  Do(11 downto 8) <= Di(15 downto 12);
  Do(15 downto 12) <= Di(11 downto 8);
end Behavioral;

LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.numeric_std.all;

entity DIG_Neg is
  generic ( Bits: integer ); 
  port (
    p_in: in std_logic_vector ((Bits-1) downto 0);
    p_out: out std_logic_vector ((Bits-1) downto 0) );
end DIG_Neg;

architecture Behavioral of DIG_Neg is
begin
    p_out <= std_logic_vector(-signed(p_in));
end Behavioral;


LIBRARY ieee;
USE ieee.std_logic_1164.all;
entity DIG_Add_12 is
  port (
    s   : out std_logic_vector((12 - 1) downto 0);
    c_o : out std_logic;
    a   : in  std_logic_vector((12 - 1) downto 0);
    b   : in  std_logic_vector((12 - 1) downto 0);
    c_i : in  std_logic);
end entity;
architecture Behavioral of  DIG_Add_12 is
  function FullAdder(input1, input2, Cin : std_logic) return std_logic is
  begin
    return (input1 xor input2 xor Cin);
  end function;
  function CarryOut(input1, input2, Cin : std_logic) return std_logic is
  begin
    return ((input1 and input2) or (Cin and (input1 xor input2)));
  end function;
  signal Carry : std_logic;
  signal temp  : std_logic_vector(8 downto 0);
begin
  process (a, b, c_i)
  begin
    Carry <= c_i;
    for i in 0 to 12 - 1 loop
      s(i) <= FullAdder(a(i), b(i), Carry);
      Carry <= CarryOut(a(i), b(i), Carry);
    end loop;
    c_o <= Carry;
  end process;
end architecture;


LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.numeric_std.all;

entity adder12 is
  port (
    A: in std_logic_vector(11 downto 0);
    B: in std_logic_vector(11 downto 0);
    c_i: in std_logic;
    s: out std_logic_vector(11 downto 0);
    c_o: out std_logic);
end adder12;

architecture Behavioral of adder12 is
begin
  gate0: entity work.DIG_Add_12 -- DIG_Add_12
    port map (
      a => A,
      b => B,
      c_i => c_i,
      s => s,
      c_o => c_o);
end Behavioral;

LIBRARY ieee;
USE ieee.std_logic_1164.all;
entity DIG_Add is
  port (
    s   : out std_logic_vector((16 - 1) downto 0);
    c_o : out std_logic;
    a   : in  std_logic_vector((16 - 1) downto 0);
    b   : in  std_logic_vector((16 - 1) downto 0);
    c_i : in  std_logic);
end entity;
architecture Behavioral of DIG_Add is
  function FullAdder(input1, input2, Cin : std_logic) return std_logic is
  begin
    return (input1 xor input2 xor Cin);
  end function;
  function CarryOut(input1, input2, Cin : std_logic) return std_logic is
  begin
    return ((input1 and input2) or (Cin and (input1 xor input2)));
  end function;
  signal Carry : std_logic;
  signal temp  : std_logic_vector(16 downto 0);
begin
  process (a, b, c_i)
  begin
    Carry <= c_i;
    for i in 0 to 16- 1 loop
      s(i) <= FullAdder(a(i), b(i), Carry);
      Carry <= CarryOut(a(i), b(i), Carry);
    end loop;
    c_o <= Carry;
  end process;
end architecture;


LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.numeric_std.all;

entity adder16 is
  port (
    a: in std_logic_vector(15 downto 0);
    b: in std_logic_vector(15 downto 0);
    c_i: in std_logic;
    s: out std_logic_vector(15 downto 0);
    c_o: out std_logic);
end adder16;

architecture Behavioral of adder16 is
begin
  gate0: entity work.DIG_Add -- DIG_Add
    port map (
      a => a,
      b => b,
      c_i => c_i,
      s => s,
      c_o => c_o);
end Behavioral;

LIBRARY ieee;
USE ieee.std_logic_1164.all;
--USE ieee.std_logic_unsigned.all;
entity DIG_Sub is
  port (
    s   : out std_logic_vector((16 - 1) downto 0);
    c_o : out std_logic;
    a   : in  std_logic_vector((16 - 1) downto 0);
    b   : in  std_logic_vector((16 - 1) downto 0);
    c_i : in  std_logic);
end entity;
architecture Behavioral of DIG_Sub is
  function FullSubtractor(input1, input2, Bin : std_logic) return std_logic is
  begin
    return (input1 xor input2 xor Bin);
  end function;
  function BorrowOut(input1, input2, Bin : std_logic) return std_logic is
  begin
    return ((not input1 and input2) or ((not input1) and Bin) or (Bin and input2));
  end function;
  signal Temp_Borrow : std_logic;
begin
  process (a, b, c_i)
  begin
    Temp_Borrow <= c_i;
    for i in 0 to 16 - 1 loop
      s(i) <= FullSubtractor(a(i), b(i), Temp_Borrow);
      Temp_Borrow <= BorrowOut(a(i), b(i), Temp_Borrow);
    end loop;
    c_o <= Temp_Borrow;
  end process;
end architecture;


LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.numeric_std.all;

entity subber16 is
  port (
    a: in std_logic_vector(15 downto 0);
    b: in std_logic_vector(15 downto 0);
    c_i: in std_logic;
    s: out std_logic_vector(15 downto 0);
    c_o: out std_logic);
end subber16;

architecture Behavioral of subber16 is
begin
  gate0: entity work.DIG_Sub -- DIG_Sub
    port map (
      a => a,
      b => b,
      c_i => c_i,
      s => s,
      c_o => c_o);
end Behavioral;

LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.numeric_std.all;

entity tt_um_smallcpu is
  port (
    ui_in: in std_logic_vector(7 downto 0);
    uio_in: in std_logic_vector(7 downto 0);
    ena: in std_logic;
    clk: in std_logic;
    rst_n: in std_logic;
    uo_out: out std_logic_vector(7 downto 0);
    uio_out: out std_logic_vector(7 downto 0);
    uio_oe: out std_logic_vector(7 downto 0));
end tt_um_smallcpu;

architecture Behavioral of tt_um_smallcpu is
  signal muxA: std_logic;
  signal s0: std_logic_vector(15 downto 0);
  signal s1: std_logic_vector(15 downto 0);
  signal s2: std_logic_vector(15 downto 0);
  signal muxB: std_logic_vector(2 downto 0);
  signal s3: std_logic_vector(15 downto 0);
  signal s4: std_logic_vector(15 downto 0);
  signal s5: std_logic_vector(15 downto 0);
  signal s6: std_logic_vector(15 downto 0);
  signal s7: std_logic_vector(15 downto 0);
  signal s8: std_logic_vector(15 downto 0);
  signal s9: std_logic_vector(3 downto 0);
  signal s10: std_logic_vector(3 downto 0);
  signal OPcode: std_logic_vector(7 downto 0);
  signal s11: std_logic_vector(4 downto 0);
  signal st: std_logic;
  signal s12: std_logic;
  signal ld: std_logic;
  signal s13: std_logic_vector(15 downto 0);
  signal WDmux: std_logic_vector(2 downto 0);
  signal s14: std_logic_vector(15 downto 0);
  signal Din: std_logic_vector(15 downto 0);
  signal s15: std_logic_vector(15 downto 0);
  signal RandomNUM: std_logic_vector(15 downto 0);
  signal s16: std_logic_vector(15 downto 0);
  signal s17: std_logic_vector(1 downto 0);
  signal s18: std_logic;
  signal s19: std_logic;
  signal s20: std_logic;
  signal s21: std_logic;
  signal s22: std_logic;
  signal br: std_logic_vector(2 downto 0);
  signal s23: std_logic;
  signal sf: std_logic;
  signal s24: std_logic;
  signal s25: std_logic;
  signal FlagOut: std_logic_vector(15 downto 0);
  signal WE: std_logic;
  signal imm: std_logic;
  signal iem: std_logic_vector(1 downto 0);
  signal s26: std_logic_vector(11 downto 0);
  signal s27: std_logic;
  signal pcOut: std_logic_vector(11 downto 0);
  signal s28: std_logic_vector(11 downto 0);
  signal s29: std_logic_vector(11 downto 0);
  signal s30: std_logic_vector(11 downto 0);
  signal p_abs: std_logic;
  signal s31: std_logic_vector(11 downto 0);
  signal s32: std_logic;
  signal ioW: std_logic;
  signal s33: std_logic;
  signal s34: std_logic_vector(3 downto 0);
  signal outputToOutside: std_logic_vector(3 downto 0);
  signal sel: std_logic_vector(3 downto 0);
  signal s35: std_logic_vector(15 downto 0);
  signal s36: std_logic_vector(15 downto 0);
  signal s37: std_logic_vector(15 downto 0);
  signal s38: std_logic_vector(15 downto 0);
  signal s39: std_logic_vector(15 downto 0);
  signal s40: std_logic_vector(15 downto 0);
  signal s41: std_logic_vector(15 downto 0);
  signal s42: std_logic_vector(15 downto 0);
  signal s43: std_logic_vector(15 downto 0);
  signal s44: std_logic_vector(15 downto 0);
  signal s45: std_logic_vector(15 downto 0);
  signal s46: std_logic_vector(15 downto 0);
  signal s47: std_logic;
  signal s48: std_logic;
  signal s49: std_logic;
  signal s50: std_logic;
  signal s51: std_logic;
  signal aluOp: std_logic_vector(4 downto 0);
  signal s52: std_logic;
  signal s53: std_logic;
  signal s54: std_logic;
  signal s55: std_logic;
  signal s56: std_logic;
  signal s57: std_logic;
  signal s58: std_logic_vector(15 downto 0);
  signal s59: std_logic_vector(15 downto 0);
  signal s60: std_logic;
  signal s61: std_logic;
  signal s62: std_logic;
  signal s63: std_logic;
  signal s64: std_logic;
  signal s65: std_logic;
  signal s66: std_logic;
  signal s67: std_logic;
  signal s68: std_logic;
  signal s69: std_logic;
  signal s70: std_logic;
  signal s71: std_logic;
  signal s72: std_logic;
  signal s73: std_logic;
  signal s74: std_logic;
  signal s75: std_logic;
  signal s76: std_logic;
  signal s77: std_logic;
  signal s78: std_logic;
  signal s79: std_logic;
  signal s80: std_logic;
  signal s81: std_logic;
  signal s82: std_logic;
  signal s83: std_logic;
  signal s84: std_logic;
  signal s85: std_logic;
  signal s86: std_logic;
  signal s87: std_logic;
  signal s88: std_logic;
  signal s89: std_logic;
  signal s90: std_logic;
  signal s91: std_logic;
  signal s92: std_logic;
  signal s93: std_logic;
  signal s94: std_logic;
  signal s95: std_logic;
  signal stPC: std_logic;
  signal RandomNUMSel: std_logic;
  signal ioR: std_logic;
  signal s96: std_logic_vector(6 downto 0);
  signal s97: std_logic_vector(6 downto 0);
  signal s98: std_logic;
  signal s99: std_logic;
  signal s100: std_logic;
  signal s101: std_logic;
  signal s102: std_logic;
  signal s103: std_logic;
  signal s104: std_logic;
  signal s105: std_logic;
  signal s106: std_logic;
  signal s107: std_logic;
  signal src2D: std_logic;
  signal s108: std_logic;
  signal s109: std_logic;
  signal s110: std_logic;
  signal s111: std_logic;
  signal s112: std_logic;
  signal alu2D: std_logic;
  signal s113: std_logic;
  signal s114: std_logic;
  signal s115: std_logic;
  signal s116: std_logic;
  signal s117: std_logic;
  signal Reti: std_logic;
  signal s118: std_logic;
  signal s119: std_logic;
  signal s120: std_logic_vector(3 downto 0);
  signal outputToOutsideEnable: std_logic_vector(3 downto 0);
  signal s121: std_logic;
  signal s122: std_logic;
  signal s123: std_logic_vector(7 downto 0);
  signal s124: std_logic;
  signal s125: std_logic_vector(7 downto 0);
  signal s126: std_logic_vector(1 downto 0);
  signal s127: std_logic;
  signal s128: std_logic;
  signal s129: std_logic;
begin
  Din(0) <= uio_in(0);
  Din(1) <= uio_in(1);
  Din(2) <= uio_in(2);
  Din(3) <= uio_in(3);
  Din(4) <= uio_in(4);
  Din(5) <= uio_in(5);
  Din(6) <= uio_in(6);
  Din(7) <= uio_in(7);
  Din(8) <= '0';
  Din(9) <= '0';
  Din(10) <= '0';
  Din(11) <= '0';
  Din(12) <= '0';
  Din(13) <= '0';
  Din(14) <= '0';
  Din(15) <= '0';
  s121 <= NOT clk;
  gate0: entity work.DIG_Counter -- DIG_Counter
    port map (
      en => '1',
      C => clk,
      clr => rst_n,
      p_out => s126,
      ovf => s129);
  s127 <= s126(0);
  s128 <= s126(1);
  s122 <= (s127 AND NOT s128);
  s124 <= (NOT s127 AND s128);
  s12 <= (s127 AND s128);
  s27 <= NOT s12;
  gate1: entity work.DIG_Register_BUS
    generic map (
      Bits => 8)
    port map (
      D => ui_in,
      C => s121,
      en => s122,
      Q => s123);
  gate2: entity work.DIG_Register_BUS
    generic map (
      Bits => 8)
    port map (
      D => ui_in,
      C => s121,
      en => s124,
      Q => s125);
  s8(7 downto 0) <= s125;
  s8(15 downto 8) <= s123;
  gate3: entity work.singExtend
    port map (
      inst => s8,
      n4S => s4,
      n8SD => s5,
      n4D => s6);
  s9 <= s8(3 downto 0);
  s10 <= s8(7 downto 4);
  OPcode <= s8(15 downto 8);
  s96 <= OPcode(6 downto 0);
  imm <= OPcode(7);
  gate4: entity work.MUX_GATE_BUS_1
    generic map (
      Bits => 7)
    port map (
      sel => imm,
      in_0 => s96,
      in_1 => "0000000",
      p_out => s97);
  s104 <= s97(0);
  s103 <= s97(1);
  s102 <= s97(2);
  s101 <= s97(3);
  s100 <= s97(4);
  s99 <= s97(5);
  s98 <= s97(6);
  gate5: entity work.controllogic
    port map (
      A => s98,
      B => s99,
      C => s100,
      D => s101,
      E => s102,
      F => s103,
      G => s104,
      muxb0 => s105,
      muxb1 => s106,
      muxb2 => s107,
      src2D => src2D,
      aluop0 => s108,
      aluop1 => s109,
      aluop2 => s110,
      aluop3 => s111,
      aluop4 => s112,
      WE => WE,
      sf => sf,
      alu2D => alu2D,
      iem0 => s113,
      iem1 => s114,
      br0 => s115,
      br1 => s116,
      br2 => s117,
      muxA => muxA,
      ld => ld,
      st => st,
      p_abs => p_abs,
      ioW => ioW,
      ioR => ioR,
      stPC => stPC,
      Reti => Reti,
      rand => RandomNUMSel);
  WDmux(0) <= (stPC OR ld OR RandomNUMSel);
  WDmux(1) <= (ioR OR stPC);
  WDmux(2) <= RandomNUMSel;
  muxB(0) <= s107;
  muxB(1) <= s106;
  muxB(2) <= s105;
  aluOp(0) <= s112;
  aluOp(1) <= s111;
  aluOp(2) <= s110;
  aluOp(3) <= s109;
  aluOp(4) <= s108;
  br(0) <= s117;
  br(1) <= s116;
  br(2) <= s115;
  iem(0) <= s114;
  iem(1) <= s113;
  gate6: entity work.ImReg
    port map (
      en => imm,
      iem => iem,
      C => s12,
      inst => s8,
      imm => s3);
  s17 <= br(1 downto 0);
  sel <= aluOp(3 downto 0);
  gate7: entity work.MUX_GATE_BUS_1
    generic map (
      Bits => 16)
    port map (
      sel => muxA,
      in_0 => s0,
      in_1 => s1,
      p_out => s2);
  gate8: entity work.MUX_GATE_BUS_3
    generic map (
      Bits => 16)
    port map (
      sel => muxB,
      in_0 => s1,
      in_1 => "0000000000000000",
      in_2 => s3,
      in_3 => "0000000000000000",
      in_4 => "0000000000000000",
      in_5 => s4,
      in_6 => s5,
      in_7 => s6,
      p_out => s7);
  gate9: entity work.DIG_RAMDualPort -- mem
    generic map (
      Bits => 16,
      AddrBits => 5)
    port map (
      A => s11,
      Din => s1,
      str => st,
      C => s12,
      ld => ld,
      D => s13);
  gate10: entity work.MUX_GATE_BUS_3
    generic map (
      Bits => 16)
    port map (
      sel => WDmux,
      in_0 => s14,
      in_1 => s13,
      in_2 => Din,
      in_3 => s15,
      in_4 => "0000000000000000",
      in_5 => RandomNUM,
      in_6 => "0000000000000000",
      in_7 => "0000000000000000",
      p_out => s16);
  gate11: entity work.MUX_GATE_2
    port map (
      sel => s17,
      in_0 => '0',
      in_1 => s18,
      in_2 => s19,
      in_3 => s20,
      p_out => s21);
  s22 <= (s21 XOR br(2));
  gate12: entity work.DIG_Register -- Carry
    port map (
      D => s23,
      C => s12,
      en => sf,
      Q => s18);
  gate13: entity work.DIG_Register -- Zero
    port map (
      D => s24,
      C => s12,
      en => sf,
      Q => s19);
  gate14: entity work.DIG_Register -- Neg
    port map (
      D => s25,
      C => s12,
      en => sf,
      Q => s20);
  gate15: entity work.RegisterBlock
    port map (
      DataIn => s16,
      WE => WE,
      clk => s12,
      src => s9,
      Dest => s10,
      RDest => s0,
      Rsrc => s1);
  gate16: entity work.DIG_Register_BUS -- PC
    generic map (
      Bits => 12)
    port map (
      D => s26,
      C => s27,
      en => '1',
      Q => pcOut);
  gate17: entity work.MUX_GATE_BUS_1
    generic map (
      Bits => 12)
    port map (
      sel => p_abs,
      in_0 => s30,
      in_1 => s31,
      p_out => s26);
  s33 <= (s32 AND ioW);
  gate18: entity work.DIG_Register_BUS
    generic map (
      Bits => 4)
    port map (
      D => s34,
      C => s12,
      en => s33,
      Q => outputToOutside);
  gate19: entity work.MUX_GATE_BUS_4
    generic map (
      Bits => 16)
    port map (
      sel => sel,
      in_0 => s7,
      in_1 => s35,
      in_2 => s36,
      in_3 => s37,
      in_4 => s38,
      in_5 => s39,
      in_6 => s40,
      in_7 => s41,
      in_8 => s42,
      in_9 => s43,
      in_10 => s44,
      in_11 => s45,
      in_12 => s46,
      in_13 => "0000000000000000",
      in_14 => "0000000000000000",
      in_15 => "0000000000000000",
      p_out => s14);
  gate20: entity work.MUX_GATE_4
    port map (
      sel => sel,
      in_0 => '0',
      in_1 => s47,
      in_2 => s48,
      in_3 => '0',
      in_4 => '0',
      in_5 => '0',
      in_6 => '0',
      in_7 => '0',
      in_8 => s49,
      in_9 => s50,
      in_10 => s51,
      in_11 => '0',
      in_12 => '0',
      in_13 => '0',
      in_14 => '0',
      in_15 => '0',
      p_out => s23);
  s52 <= (aluOp(4) AND s18);
  gate21: entity work.DIG_Register_BUS -- seed
    generic map (
      Bits => 16)
    port map (
      D => s1,
      C => s12,
      en => s57,
      Q => s58);
  s57 <= (s60 AND ioW);
  gate22: entity work.DIG_JK_FF
    generic map (
      tempvar => '0')
    port map (
      J => s61,
      C => s12,
      K => s61,
      Q => s55);
  gate23: entity work.DIG_D_FF_AS
    port map (
      Set => s63,
      D => s64,
      C => s12,
      Clr => s62,
      Q => s65);
  gate24: entity work.DIG_D_FF_AS
    port map (
      Set => s66,
      D => s65,
      C => s12,
      Clr => s62,
      Q => s67);
  gate25: entity work.DIG_D_FF_AS
    port map (
      Set => s68,
      D => s67,
      C => s12,
      Clr => s62,
      Q => s69);
  gate26: entity work.DIG_D_FF_AS
    port map (
      Set => s70,
      D => s69,
      C => s12,
      Clr => s62,
      Q => s71);
  gate27: entity work.DIG_D_FF_AS
    port map (
      Set => s72,
      D => s71,
      C => s12,
      Clr => s62,
      Q => s73);
  gate28: entity work.DIG_D_FF_AS
    port map (
      Set => s74,
      D => s73,
      C => s12,
      Clr => s62,
      Q => s75);
  gate29: entity work.DIG_D_FF_AS
    port map (
      Set => s76,
      D => s75,
      C => s12,
      Clr => s62,
      Q => s77);
  gate30: entity work.DIG_D_FF_AS
    port map (
      Set => s78,
      D => s77,
      C => s12,
      Clr => s62,
      Q => s79);
  gate31: entity work.DIG_D_FF_AS
    port map (
      Set => s80,
      D => s79,
      C => s12,
      Clr => s62,
      Q => s81);
  gate32: entity work.DIG_D_FF_AS
    port map (
      Set => s82,
      D => s81,
      C => s12,
      Clr => s62,
      Q => s83);
  gate33: entity work.DIG_D_FF_AS
    port map (
      Set => s84,
      D => s83,
      C => s12,
      Clr => s62,
      Q => s85);
  gate34: entity work.DIG_D_FF_AS
    port map (
      Set => s86,
      D => s85,
      C => s12,
      Clr => s62,
      Q => s87);
  gate35: entity work.DIG_D_FF_AS
    port map (
      Set => s88,
      D => s87,
      C => s12,
      Clr => s62,
      Q => s89);
  gate36: entity work.DIG_D_FF_AS
    port map (
      Set => s90,
      D => s89,
      C => s12,
      Clr => s62,
      Q => s91);
  gate37: entity work.DIG_D_FF_AS
    port map (
      Set => s92,
      D => s91,
      C => s12,
      Clr => s62,
      Q => s93);
  gate38: entity work.DIG_D_FF_AS
    port map (
      Set => s94,
      D => s93,
      C => s12,
      Clr => s62,
      Q => s95);
  s54 <= (s12 AND s57);
  s119 <= (s118 AND ioW);
  gate39: entity work.DIG_Register_BUS
    generic map (
      Bits => 4)
    port map (
      D => s120,
      C => s12,
      en => s119,
      Q => outputToOutsideEnable);
  FlagOut(0) <= s18;
  FlagOut(1) <= s19;
  FlagOut(2) <= s20;
  FlagOut(15 downto 3) <= "0000000000000";
  gate40: entity work.COMP_GATE_SIGNED
    generic map (
      Bits => 16)
    port map (
      a => s14,
      b => "0000000000000101",
      eq => s32);
  s37 <= (s2 AND s7);
  s38 <= (s2 OR s7);
  s39 <= (s2 XOR s7);
  gate41: entity work.COMP_GATE_SIGNED
    generic map (
      Bits => 16)
    port map (
      a => s14,
      b => "0000000000000000",
      eq => s24);
  gate42: entity work.LSL
    port map (
      Di => s2,
      Ci => s52,
      Do => s42,
      Co => s49);
  gate43: entity work.LSR
    port map (
      Di => s2,
      Ci => s52,
      Do => s43,
      Co => s50);
  gate44: entity work.ASR
    port map (
      Di => s2,
      C => s51,
      Do => s44);
  gate45: entity work.SWAP
    port map (
      Di => s2,
      Do => s45);
  gate46: entity work.SWAPN
    port map (
      Di => s2,
      Do => s46);
  s40 <= NOT s2;
  gate47: entity work.DIG_Neg
    generic map (
      Bits => 16)
    port map (
      p_in => s2,
      p_out => s41);
  gate48: entity work.MUX_GATE_BUS_1
    generic map (
      Bits => 16)
    port map (
      sel => s57,
      in_0 => "0000000000000000",
      in_1 => s58,
      p_out => s59);
  gate49: entity work.COMP_GATE_SIGNED
    generic map (
      Bits => 16)
    port map (
      a => s14,
      b => "0000000000001000",
      eq => s60);
  s64 <= (s75 XOR (s85 XOR (s89 XOR s93)));
  RandomNUM(0) <= s65;
  RandomNUM(1) <= s67;
  RandomNUM(2) <= s69;
  RandomNUM(3) <= s71;
  RandomNUM(4) <= s73;
  RandomNUM(5) <= s75;
  RandomNUM(6) <= s77;
  RandomNUM(7) <= s79;
  RandomNUM(8) <= s81;
  RandomNUM(9) <= s83;
  RandomNUM(10) <= s85;
  RandomNUM(11) <= s87;
  RandomNUM(12) <= s89;
  RandomNUM(13) <= s91;
  RandomNUM(14) <= s93;
  RandomNUM(15) <= s95;
  gate50: entity work.COMP_GATE_SIGNED
    generic map (
      Bits => 16)
    port map (
      a => s14,
      b => "0000000000000110",
      eq => s118);
  uio_out(3 downto 0) <= pcOut(11 downto 8);
  uio_out(7 downto 4) <= outputToOutside;
  uio_oe(3 downto 0) <= "0000";
  uio_oe(7 downto 4) <= outputToOutsideEnable;
  gate51: entity work.adder12
    port map (
      A => pcOut,
      B => "000000000001",
      c_i => '0',
      s => s28);
  gate52: entity work.adder16 -- addr
    port map (
      a => s2,
      b => s7,
      c_i => s52,
      s => s35,
      c_o => s47);
  gate53: entity work.subber16 -- subbr
    port map (
      a => s2,
      b => s7,
      c_i => s52,
      s => s36,
      c_o => s48);
  s11 <= s14(4 downto 0);
  s34 <= s1(3 downto 0);
  s25 <= s14(15);
  s31 <= s14(11 downto 0);
  s120 <= s1(3 downto 0);
  uo_out <= pcOut(7 downto 0);
  s15(11 downto 0) <= s28;
  s15(15 downto 12) <= "0000";
  gate54: entity work.adder12
    port map (
      A => s28,
      B => s31,
      c_i => '0',
      s => s29);
  s63 <= s59(0);
  s66 <= s59(1);
  s68 <= s59(2);
  s70 <= s59(3);
  s72 <= s59(4);
  s74 <= s59(5);
  s76 <= s59(6);
  s78 <= s59(7);
  s80 <= s59(8);
  s82 <= s59(9);
  s84 <= s59(10);
  s86 <= s59(11);
  s88 <= s59(12);
  s90 <= s59(13);
  s92 <= s59(14);
  s94 <= s59(15);
  gate55: entity work.MUX_GATE_BUS_1
    generic map (
      Bits => 12)
    port map (
      sel => s22,
      in_0 => s28,
      in_1 => s29,
      p_out => s30);
  gate56: entity work.DIG_D_FF_AS
    port map (
      Set => '0',
      D => s53,
      C => s54,
      Clr => s55,
      Q => s56,
      notQ => s53);
  s61 <= (s56 OR s55);
  s62 <= (s57 AND NOT s61);
end Behavioral;
